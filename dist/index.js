#!/usr/bin/env node
var St=Object.defineProperty;var d=(n,e)=>St(n,"name",{value:e,configurable:!0});import{StdioServerTransport as gs}from"@modelcontextprotocol/sdk/server/stdio.js";import{Server as as}from"@modelcontextprotocol/sdk/server/index.js";import{CallToolRequestSchema as ls,ListToolsRequestSchema as cs,ListPromptsRequestSchema as ds,GetPromptRequestSchema as us}from"@modelcontextprotocol/sdk/types.js";import ps from"ajv";var j="1.0.0",ce="QA Agent";import M from"fs";import It from"os";import de from"path";var te=d(n=>(...e)=>{M.appendFileSync(n,`[${new Date().toISOString()}] ${Array.isArray(e)?e.join(" "):e}
`)},"logToFile"),s=te("/tmp/mcp-evaluator-debug.log");function ue(){switch(It.platform()){case"darwin":return"macos";case"win32":case"cygwin":return"windows";case"linux":case"android":return"linux";case"aix":case"freebsd":case"openbsd":case"netbsd":case"sunos":case"haiku":default:return"unix"}}d(ue,"getOSName");function Ie(n){return typeof n=="string"?n:""}d(Ie,"safeString");function N(n,e){if(!n||typeof n!="string"||!e||typeof e!="string")return!1;try{return n.toLowerCase().includes(e.toLowerCase())}catch{return!1}}d(N,"safeIncludes");function Ct(){try{let n=Ie(process.argv?.[0]),e=Ie(process.execPath),t=Ie(process.env._);return{name:n.toLowerCase(),execPath:e.toLowerCase(),argv0:t.toLowerCase()}}catch{return{name:"",execPath:"",argv0:""}}}d(Ct,"getProcessInfo");function Ge(){try{let n=process.env||{},e=Ct();if(n.VSCODE_PID||n.VSCODE_CWD||n.VSCODE_INJECTION||n.VSCODE_IPC_HOOK||n.VSCODE_IPC_HOOK_CLI)return N(e.name,"cursor")||N(e.execPath,"cursor")||N(e.argv0,"cursor")||n.CURSOR_USER_DATA_DIR||n.CURSOR_LOGS_DIR?"cursor":"vscode";if(n.TERM_PROGRAM&&typeof n.TERM_PROGRAM=="string")try{switch(n.TERM_PROGRAM.toLowerCase()){case"cursor":return"cursor";case"vscode":return"vscode";case"iterm.app":case"apple_terminal":case"hyper":case"wezterm":case"alacritty":return"terminal"}}catch{}if(n.VIMRUNTIME||n.VIM)return"vim";if(n.INSIDE_EMACS)return"emacs";if(["idea","webstorm","pycharm","phpstorm","intellij"].some(i=>N(e.name,i)||N(e.execPath,i)||N(e.argv0,i))||N(e.execPath,"jetbrains"))return"jetbrains";if(N(e.name,"sublime")||N(e.execPath,"sublime")||N(e.argv0,"sublime"))return"sublime";if(n.TERM&&typeof n.TERM=="string"){if(n.SSH_CLIENT||n.SSH_TTY||n.SSH_CONNECTION)return"terminal";try{let i=n.TERM.toLowerCase();if(i.includes("xterm")||i.includes("screen")||i.includes("tmux")||i==="linux"||i==="vt100"||i==="vt102")return"terminal"}catch{}}return"terminal"}catch{return"terminal"}}d(Ge,"getCodingPlatform");var We=d(async(n,e,t)=>{let r=new Array(n.length),i=new Set,o=!1,a=-1,p=d(async()=>{try{let l=n.map((g,u)=>u).filter(g=>!i.has(g));l.length>0&&await t(l)}catch(l){console.error("onAborted failed: ",l)}},"abortRemaining");return new Promise((l,g)=>{n.forEach((u,m)=>{u.then(async h=>{if(!o){i.add(m),r[m]=h;try{await e(m,h)?i.size===n.length&&l(r):(o=!0,a=m,await p(),l([r[a]]))}catch(y){await p(),g(y)}}}).catch(async h=>{o||(o=!0,i.add(m),await p(),g(h))})})})},"failFast"),qe=process.env.JEST_WORKER_ID!==void 0||!1,E=d(n=>JSON.stringify({message:n.message,stack:n.stack}),"stringifyError"),pe=d((n,e,t="s")=>n>0&&n<=1?e:`${e}${t}`,"toPlural"),Pt=d((n,e)=>{let t=de.join(n,".debug"),r=de.join(t,"screenshots",e);return M.existsSync(t)||M.mkdirSync(t,{recursive:!0}),M.existsSync(r)||M.mkdirSync(r,{recursive:!0}),{debugRoot:t,screenshotsDir:r}},"createDebugFolder"),Je=d((n,e,t,r,i)=>{let{screenshotsDir:o}=Pt(n,e),a=de.join(o,t);M.existsSync(a)||M.mkdirSync(a,{recursive:!0});let l=Date.now().toString().slice(-4),g=`step-${r}-${l}.base64`,u=de.join(a,g);try{return M.writeFileSync(u,i,"utf8"),s(`[DEBUG] Screenshot saved: ${u}`),u}catch(m){throw s(`[DEBUG] Failed to save screenshot: ${E(m)}`),m}},"saveScreenshot");import{parse as Rt}from"csv-parse";var G=d(async n=>new Promise(e=>{let t=0,r=!1,i=Rt({delimiter:"|",skip_empty_lines:!0,trim:!0});i.on("readable",function(){let o;for(;o=i.read();)t++,!(typeof o[0]=="string"&&o[0].startsWith("#"))&&o.length>3&&(r=!0)}),i.on("error",function(o){e({isValid:!1,error:o.message})}),i.on("end",function(){e({isValid:t>0&&r,error:r?void 0:"CSV must have rows with more than 3 columns"})}),i.write(n),i.end()}),"validateCSVFormat");import At from"puppeteer";import*as Ke from"readline";var Ce=class{static{d(this,"BrowserRegistry")}browsers=new Map;cleanupInProgress=!1;registryId=0;handlingError=!1;cleanupTimeout=5e3;rlInterface;constructor(e=5e3){this.cleanupTimeout=e,this.setupProcessHandlers()}setupProcessHandlers(){let e=["SIGINT","SIGTERM","SIGQUIT","SIGABRT","SIGHUP"];for(let t of e)process.on(t,()=>{s(`[BrowserRegistry] Received ${t}, cleaning up browsers...`),this.safeCleanupAndExit(0,`${t} signal`)});process.platform==="win32"&&(this.rlInterface=Ke.createInterface({input:process.stdin,output:process.stdout}),this.rlInterface.on("SIGINT",()=>{s("[BrowserRegistry] Received SIGINT (Windows), cleaning up browsers..."),this.safeCleanupAndExit(0,"Windows SIGINT")})),process.on("uncaughtException",t=>{if(this.handlingError){console.error("[BrowserRegistry] Fatal: Error during error handling:",t),process.exit(1);return}this.handlingError=!0,s(`[BrowserRegistry] Uncaught exception: ${E(t)}`),this.safeCleanupAndExit(1,"uncaught exception")}),process.on("unhandledRejection",t=>{if(this.handlingError){console.error("[BrowserRegistry] Fatal: Unhandled rejection during error handling:",t),process.exit(1);return}this.handlingError=!0,s(`[BrowserRegistry] Unhandled promise rejection: ${E(t)}`),this.safeCleanupAndExit(1,"unhandled rejection")}),process.on("beforeExit",t=>{this.browsers.size>0&&!this.cleanupInProgress&&!this.handlingError&&(s(`[BrowserRegistry] beforeExit triggered with code ${t}, ${this.browsers.size} browsers still open`),this.safeCleanupAndExit(t,"beforeExit"))}),process.on("exit",t=>{if(s(`[BrowserRegistry] Process exiting with code ${t}`),this.browsers.size>0){s(`[BrowserRegistry] WARNING: ${this.browsers.size} browsers still registered at exit!`);let r=Array.from(this.browsers.values()).map(i=>`${i.id}: ${i.description}`).join(", ");s(`[BrowserRegistry] Open browsers: ${r}`)}this.rlInterface&&this.rlInterface.close()}),s(`[BrowserRegistry] Process handlers initialized (cleanup timeout: ${this.cleanupTimeout}ms)`)}async safeCleanupAndExit(e,t){if(this.cleanupInProgress){s(`[BrowserRegistry] Cleanup already in progress for ${t}, waiting...`);return}try{await this.cleanup(),s(`[BrowserRegistry] Cleanup complete for ${t}`)}catch(r){s(`[BrowserRegistry] Cleanup failed for ${t}: ${E(r)}`)}finally{process.exit(e)}}register(e,t){let r=`browser-${++this.registryId}`;return this.browsers.set(r,{id:r,browser:e,description:t,registeredAt:Date.now()}),s(`[BrowserRegistry] Registered browser ${r}: ${t} (total: ${this.browsers.size})`),r}unregister(e){this.browsers.get(e)&&this.browsers.delete(e)}getCount(){return this.browsers.size}getRegisteredBrowsers(){let e=Date.now();return Array.from(this.browsers.values()).map(t=>({id:t.id,description:t.description,registeredAt:t.registeredAt,ageMs:e-t.registeredAt}))}async cleanup(){if(this.cleanupInProgress){s("[BrowserRegistry] Cleanup already in progress, skipping...");return}this.cleanupInProgress=!0;let e=this.browsers.size;if(e===0){s("[BrowserRegistry] No browsers to cleanup");return}s(`[BrowserRegistry] Starting cleanup of ${e} browsers...`);let t=Array.from(this.browsers.values()).map(async i=>{let o=Date.now();try{s(`[BrowserRegistry] Closing browser ${i.id}: ${i.description} (age: ${o-i.registeredAt}ms)`),await i.browser.close();let a=Date.now()-o;s(`[BrowserRegistry] Successfully closed browser ${i.id} in ${a}ms`)}catch(a){let p=Date.now()-o;s(`[BrowserRegistry] Error closing browser ${i.id} after ${p}ms: ${E(a)}`)}}),r=new Promise((i,o)=>setTimeout(()=>o(new Error(`Cleanup timeout after ${this.cleanupTimeout}ms`)),this.cleanupTimeout));try{await Promise.race([Promise.allSettled(t),r]),s(`[BrowserRegistry] Normal cleanup complete. All ${e} browsers have been processed.`)}catch{s("[BrowserRegistry] Cleanup timed out, initiating force kill..."),await this.forceKill()}finally{this.browsers.clear(),this.cleanupInProgress=!1}}async forceKill(){s(`[BrowserRegistry] Force killing ${this.browsers.size} browser processes...`);let e=Array.from(this.browsers.values()).map(async t=>{try{let r=t.browser.process();r&&!r.killed?(r.kill("SIGTERM"),await new Promise(i=>setTimeout(i,100)),r.killed?s(`[BrowserRegistry] Browser process ${t.id} terminated with SIGTERM`):(r.kill("SIGKILL"),s(`[BrowserRegistry] Force killed browser process ${t.id} with SIGKILL`))):s(`[BrowserRegistry] Browser process ${t.id} already dead`)}catch(r){s(`[BrowserRegistry] Error force killing browser ${t.id}: ${E(r)}`)}});await Promise.allSettled(e),this.browsers.clear(),s("[BrowserRegistry] Force kill complete")}getDiagnostics(){let e=Date.now();return{browserCount:this.browsers.size,cleanupInProgress:this.cleanupInProgress,handlingError:this.handlingError,browsers:Array.from(this.browsers.values()).map(t=>{let r=!1;try{let i=t.browser.process();r=i?!i.killed:!1}catch{r=!1}return{id:t.id,description:t.description,ageMs:e-t.registeredAt,processAlive:r}})}}},V=new Ce(5e3);import Ye from"datadog-metrics";var W=te("/tmp/mcp-evaluator-profiling.log"),Pe=class{static{d(this,"Profiler")}timers=new Map;datadogEnabled;constructor(){this.datadogEnabled=!!process.env.DATADOG_API_KEY,this.datadogEnabled&&(Ye.init({apiKey:process.env.DATADOG_API_KEY,prefix:"mcp_evaluator_optimizer.",defaultTags:["service:mcp-evaluator-optimizer","env:production"],onError:d(e=>W(`[PROFILING] DataDog error: ${e}`),"onError")}),W("[PROFILING] DataDog profiler initialized"))}createUniqueKey(e,t){if(!t||!t.uid)throw new Error(`[PROFILING] CRITICAL: UID is required for all profiler operations. Operation: ${e}`);return`${e}-${t.uid}`}start(e,t){let r=this.createUniqueKey(e,t),i=this.formatContext(t);this.timers.set(r,{start:Date.now(),context:t}),W(`[PROFILING] START ${e}${i}`)}end(e,t){let r=this.createUniqueKey(e,t),i=this.timers.get(r);if(!i){W(`[PROFILING] ERROR: No timer found for ${e}`);return}let o=Date.now()-i.start,a={...i.context,...t},p=this.formatContext(a);W(`[PROFILING] END ${e}${p} - Duration: ${o}ms`),this.sendToDataDog(e,o,a),this.timers.delete(r)}formatContext(e){let t=[];return e.runId&&t.push(`runId=${e.runId}`),Object.keys(e).forEach(r=>{["runId"].includes(r)||t.push(`${r}=${e[r]}`)}),t.length>0?` [${t.join(", ")}]`:""}sendToDataDog(e,t,r){if(this.datadogEnabled)try{let i=e.replace(/[^a-zA-Z0-9_]/g,"_"),o=[];Ye.histogram(i,t,o)}catch(i){W(`[PROFILING] Failed to send DataDog metric: ${i}`)}}},c=new Pe;var me=class{static{d(this,"PageFreezer")}page;client;freezeTimestamp=0;isPaused=!1;async initialize(e){return this.page=e,this.client=await e.createCDPSession(),await this.client.send("Debugger.enable"),this.client.on("Debugger.paused",()=>{this.isPaused=!0}),this.client.on("Debugger.resumed",()=>{this.isPaused=!1}),this}async freeze(){if(!this.client||!this.page)throw new Error("PageFreezer not initialized");if(!this.freezeTimestamp){this.freezeTimestamp=Date.now();let e=new Promise(t=>{if(this.isPaused){t();return}let r=d(()=>{this.client.off("Debugger.paused",r),t()},"listener");this.client.on("Debugger.paused",r)});this.client.send("Runtime.evaluate",{expression:`
                    (function() {
                        window.__freezeLoopActive = true;
                        while (window.__freezeLoopActive) {
                            // This loop will run until Debugger.pause stops it
                        }
                    })();
                `,awaitPromise:!1,userGesture:!0}).catch(()=>{}),await new Promise(t=>setTimeout(t,10)),await this.client.send("Debugger.pause"),await e,await this.client.send("Runtime.evaluate",{expression:"delete window.__freezeLoopActive;",awaitPromise:!1}).catch(()=>{}),await this.client.send("Animation.enable"),await this.client.send("Animation.setPlaybackRate",{playbackRate:0})}return this}async unfreeze(){if(!this.client)throw new Error("PageFreezer not initialized");if(this.freezeTimestamp){await this.client.send("Runtime.evaluate",{expression:"window.__freezeLoopActive = false;",awaitPromise:!1}).catch(()=>{});do try{await this.client.send("Debugger.resume"),await new Promise(e=>setTimeout(e,100))}catch(e){s(E(e))}while(this.isPaused);await this.client.send("Animation.setPlaybackRate",{playbackRate:1}),this.freezeTimestamp=0}return this}async cleanup(){this.client&&(await this.unfreeze(),await this.client.send("Debugger.disable"),await this.client.send("Animation.disable"),this.client=void 0,this.page=void 0)}};var Re=!0,fe=class{static{d(this,"BrowserController")}session;webappUrl;headless;customViewport;browser;page;registryId;freezer;devicePixelRatio;constructor(e,t,r=!0,i){if(this.session=e,!t)throw new Error(`Invalid Webapp URL: "${t}"`);this.webappUrl=t,this.headless=r,this.customViewport=i}async launchBrowser(){if(s(`[BrowserController] Launching  Puppeteer browser for session ${this.session.session_uid}`),this.browser)throw new Error("Browser already launched");let e=this.session.session_uid,t=this.session.test_id;c.start("browser-launch",{uid:e,testId:t});let r;this.customViewport?(r={width:this.customViewport.width,height:this.customViewport.height,deviceScaleFactor:1},s(`[BrowserController] Using custom viewport: ${this.customViewport.width}x${this.customViewport.height}`)):(r=null,s("[BrowserController] Using system natural viewport")),this.browser=await At.launch({headless:this.headless,defaultViewport:r,args:["--disable-extensions","--disable-plugins","--disable-dev-shm-usage","--disable-gpu","--no-first-run","--disable-default-apps","--disable-background-timer-throttling","--disable-backgrounding-occluded-windows","--disable-renderer-backgrounding","--disable-blink-features=AutomationControlled","--disable-features=TranslateUI","--disable-ipc-flooding-protection","--disable-background-networking","--disable-hang-monitor","--disable-prompt-on-repost","--memory-pressure-off"]}),c.end("browser-launch",{uid:e,testId:t,result:"success"}),this.registryId=V.register(this.browser,`BrowserController-${this.session.session_uid}`),c.start("browser-new-page",{uid:e,testId:t}),this.page=await this.browser.newPage(),c.end("browser-new-page",{uid:e,testId:t,result:"success"}),this.#t(),this.freezer=Re?await new me().initialize(this.page):void 0,await this.navigateToWebapp(),await this.injectControllerScript(this.session.controller_script),s(`[BrowserController] Browser launched and controller script injected for session ${this.session.session_uid}`)}#e(){if(!this.page)throw new Error("Browser page not initialized")}#t(){if(!this.page){s("[BrowserController] Cannot setup console logging - page not initialized");return}let e=te("/tmp/mcp-evaluator-debug.log"),t=this.session.session_uid;this.page.on("console",async r=>{try{let i=r.type();if(i!=="error"&&i!=="warn")return;let o=r.location(),a=r.text(),p=await Promise.all(r.args().map(async l=>{try{return await l.jsonValue()}catch{try{return await l.toString()}catch{return"[complex object]"}}}));if(i==="error"||i==="warn"){let l=`[BROWSER-${t}] ${i.toUpperCase()}: ${a}`;e(l)}}catch(i){s(`[BrowserController] Failed to log browser console message: ${i}`)}}),this.page.on("pageerror",r=>{e(`[BROWSER-${t}] PAGE-ERROR: ${r.message}`),e(`[BROWSER-${t}] STACK: ${r.stack}`)}),this.page.on("requestfailed",r=>{e(`[BROWSER-${t}] REQUEST-FAILED: ${r.method()} ${r.url()}`),e(`[BROWSER-${t}] FAILURE: ${r.failure()?.errorText}`)}),s(`[BrowserController] Browser console logging enabled for session ${t}`)}async navigateToWebapp(){this.#e(),s(`[BrowserController] ${this.session.session_uid} navigating to webapp "${this.webappUrl}" `),c.start("browser-navigate-to-webapp",{uid:this.session.session_uid});try{await this.page.goto(this.webappUrl,{waitUntil:"domcontentloaded",timeout:6e4}),c.end("browser-navigate-to-webapp",{uid:this.session.session_uid})}catch(e){if(c.end("browser-navigate-to-webapp",{uid:this.session.session_uid,result:"error",error:e.message}),s(`[BrowserController] Navigation failed for ${this.webappUrl}: ${e.message}`),this.webappUrl.startsWith("file://")){s("[BrowserController] Retrying file URL navigation with networkidle0");try{await this.page.goto(this.webappUrl,{waitUntil:"networkidle0",timeout:9e4}),s("[BrowserController] File URL navigation succeeded on retry")}catch(t){throw s(`[BrowserController] File URL retry also failed: ${t.message}`),t}}else throw e}}async injectControllerScript(e){this.#e(),c.start("browser-inject-controller-script",{uid:this.session.session_uid}),await this.page.evaluateOnNewDocument(e),await this.page.evaluate(e),await this.page.evaluate(()=>typeof window.__puppeteerResize=="function")||await this.page.exposeFunction("__puppeteerResize",async i=>{await this.page.setViewport(i),await this.page.evaluate(o=>{window.__puppeteerBridge.dispatchEvent(new CustomEvent("viewport-changed",{detail:o}))},i)}),await this.page.evaluate(()=>typeof window.__puppeteerHover=="function")||await this.page.exposeFunction("__puppeteerHover",async(i,o)=>{try{return s(`[BrowserController] Bridge hover request: ${i} ${o?`at (${o.x}, ${o.y})`:""}`),o?(await this.page.mouse.move(o.x,o.y),await this.page.mouse.move(o.x,o.y)):await this.page.hover(i),await this.page.evaluate(a=>{window.__puppeteerBridge.dispatchEvent(new CustomEvent("hover-completed",{detail:{success:!0,selector:a.selector,coordinates:a.coordinates,timestamp:Date.now()}}))},{selector:i,coordinates:o}),!0}catch(a){let p=a instanceof Error?a.message:String(a);return s(`[BrowserController] Bridge hover failed: ${p}`),await this.page.evaluate(l=>{window.__puppeteerBridge.dispatchEvent(new CustomEvent("hover-failed",{detail:{success:!1,selector:l.selector,error:l.error,timestamp:Date.now()}}))},{selector:i,error:p}),!1}}),c.end("browser-inject-controller-script",{uid:this.session.session_uid})}async executeScript(e){this.#e(),c.start("browser-execute-script",{uid:this.session.session_uid});try{let t,r=new Promise((i,o)=>{t=setTimeout(()=>{o(new Error("Script execution timed out after 10 seconds"))},1e4)});try{await Promise.race([this.page.evaluate(e),r])}finally{clearTimeout(t)}c.end("browser-execute-script",{uid:this.session.session_uid})}catch(t){throw c.end("browser-execute-script",{uid:this.session.session_uid,result:t.message}),s(`[BrowserController ${this.session.session_uid}] script execution failed: ${t}`),t}}async focusElement(e){this.#e();let t=`[data-qa-id="${e}"]`;try{c.start("browser-focus-element",{uid:this.session.session_uid,elementId:e}),s(`[BrowserController ${this.session.session_uid}] focusing on element: ${t}`),await this.page.focus(t),c.end("browser-focus-element",{uid:this.session.session_uid,elementId:e,result:"success"}),s(`[BrowserController ${this.session.session_uid}] successfully focused on element: ${t}`)}catch(r){throw c.end("browser-focus-element",{uid:this.session.session_uid,elementId:e,result:r.message}),s(`[BrowserController ${this.session.session_uid}] failed to focus on element ${t}: ${r}`),new Error(`Failed to focus on element with selector "${t}": ${r}`)}}async clickElement(e){this.#e();let t=`[data-qa-id="${e}"]`;try{c.start("browser-click-element",{uid:this.session.session_uid,elementId:e}),s(`[BrowserController ${this.session.session_uid}] clicking on element: ${t}`),await this.page.click(t),c.end("browser-click-element",{uid:this.session.session_uid,elementId:e,result:"success"}),s(`[BrowserController ${this.session.session_uid}] successfully clicked on element: ${t}`)}catch(r){throw c.end("browser-click-element",{uid:this.session.session_uid,elementId:e,result:r.message}),s(`[BrowserController ${this.session.session_uid}] failed to click on element ${t}: ${r}`),new Error(`Failed to click on element with selector "${t}": ${r}`)}}async pressKey(e){this.#e();try{c.start("browser-press-key",{uid:this.session.session_uid,keyCode:e}),s(`[BrowserController] ${this.session.session_uid} pressing key with keyCode: ${e}`);let t;switch(e){case 8:t="Backspace";break;case 9:t="Tab";break;case 13:t="Enter";break;case 27:t="Escape";break;case 32:t="Space";break;case 37:t="ArrowLeft";break;case 38:t="ArrowUp";break;case 39:t="ArrowRight";break;case 40:t="ArrowDown";break;case 46:t="Delete";break;default:if(e>=32&&e<=126)t=String.fromCharCode(e);else throw new Error(`Unsupported keyCode: ${e}`)}await this.page.keyboard.press(t),c.end("browser-press-key",{uid:this.session.session_uid,keyCode:e,result:"success"}),s(`[BrowserController] ${this.session.session_uid} successfully pressed key: ${t} (keyCode: ${e})`)}catch(t){throw c.end("browser-press-key",{uid:this.session.session_uid,keyCode:e,result:t.message}),s(`[BrowserController] ${this.session.session_uid} failed to press key ${e}: ${t}`),new Error(`Failed to press key with keyCode "${e}": ${t}`)}}async takeScreenshot(e){this.#e(),c.start("browser-take-screenshot",{uid:this.session.session_uid});let t=await this.page.createCDPSession(),r=await this.getDevicePixelRatio(),{data:i}=await t.send("Page.captureScreenshot",{format:"png",...e?{clip:{x:e.x0,y:e.y0,width:e.x1-e.x0,height:e.y1-e.y0,scale:r}}:{captureBeyondViewport:!0}});return c.end("browser-take-screenshot",{uid:this.session.session_uid}),i}async extractDOM(){this.#e(),c.start("browser-extract-dom",{uid:this.session.session_uid});let e=await this.page.evaluate(async()=>{try{return await window.scrapeDOM()}catch(t){return console.error(`[BrowserController] [dom.callback error]
`,t),{error:t}}});return c.end("browser-extract-dom",{uid:this.session.session_uid,result:e.error?e.error.message:"success"}),e}async getViewportBounds(){this.#e(),c.start("browser-get-viewport-bounds",{uid:this.session.session_uid});let e=await this.page.evaluate(()=>{let t=window.scrollX,r=window.scrollY;return{x0:t,y0:r,x1:t+window.innerWidth,y1:r+window.innerHeight}});return c.end("browser-get-viewport-bounds",{uid:this.session.session_uid}),e}async getDevicePixelRatio(){if(this.#e(),this.devicePixelRatio)return this.devicePixelRatio;c.start("browser-get-device-pixel-ratio",{uid:this.session.session_uid});let e=await this.page.evaluate(()=>window.devicePixelRatio||1);return c.end("browser-get-device-pixel-ratio",{uid:this.session.session_uid}),this.devicePixelRatio=e,e}async getPage(){return this.#e(),this.page}async resetPageState(){this.#e(),s(`[BrowserController] resetPageState ${this.session.session_uid}`),await this.clearPageState(),await this.navigateToWebapp(),s(`[BrowserController] Re-injecting controller script after reset ${this.session.session_uid}`),this.session.controller_script&&await this.injectControllerScript(this.session.controller_script)}async freezePage(){if(Re){if(!this.freezer)throw new Error("Page freezer not initialized");s(`[BrowserController] Freezing page for session ${this.session.session_uid}`),await this.freezer.freeze()}}async unfreezePage(){if(Re){if(!this.freezer)throw new Error("Page freezer not initialized");s(`[BrowserController] Unfreezing page for session ${this.session.session_uid}`),await this.freezer.unfreeze()}}async clearPageState(){this.#e();try{c.start("browser-clear-page-state",{uid:this.session.session_uid}),s(`=== [BrowserController] clearPageState ${this.session.session_uid} ===`),await this.page.evaluate(()=>{typeof localStorage<"u"&&localStorage.clear()}),await this.page.evaluate(()=>{typeof sessionStorage<"u"&&sessionStorage.clear()});let e=await this.page.createCDPSession();await e.send("Network.clearBrowserCache"),await e.send("Network.clearBrowserCookies"),await this.page.evaluate(()=>{for(let t=1;t<1e4;t++)clearTimeout(t),clearInterval(t)}),c.end("browser-clear-page-state",{uid:this.session.session_uid,result:"success"})}catch(e){c.end("browser-clear-page-state",{uid:this.session.session_uid,result:e.message}),s(`[BrowserController] clearPageState error ${this.session.session_uid}: ${e}`)}}async cleanup(){s(`=== [BrowserController] cleanup ${this.session.session_uid} ===`);try{this.freezer&&(await this.freezer.cleanup(),this.freezer=void 0),this.browser&&(c.start("browser-cleanup",{uid:this.session.session_uid}),await this.browser.close(),this.browser=void 0,this.page=void 0,c.end("browser-cleanup",{uid:this.session.session_uid,result:"success"}))}catch(e){c.end("browser-cleanup",{uid:this.session.session_uid,result:e.message}),s(`[BrowserController] cleanup error ${this.session.session_uid}: ${e}`)}finally{this.registryId&&(V.unregister(this.registryId),this.registryId=void 0)}}};var v=class n extends Error{static{d(this,"CritiqueError")}#e;constructor(e){super(e.feedbacks?.[0]?.text||"Critique error"),this.name="CritiqueError",this.#e={...e,decision:"CRITIQUE",metadata:{...e.metadata,evaluationTime:Date.now(),evaluatorVersion:j}}}toEvaluationResult(){return this.#e}static fromError(e,t){if(e instanceof n)return e;let r=String(e?.message||e||"Unknown Error");return new n({confidence:.1,feedbacks:[{text:`Error: ${r}`,structured:{violation:`EXECUTION_ERROR: ${r}`,testId:t,severity:"BLOCKING"}}]})}},se=d((n,e)=>{throw n instanceof v?n:e},"bubbleCritiqueErrorOrThrow"),Ae=d(n=>n instanceof Error&&(n.name==="AbortError"||n.message.includes("timeout")),"isTimeoutError");var xe=class{static{d(this,"ProgressTracker")}state={progressToken:void 0,server:void 0,totalTests:0,completedTests:0};initialize(e){this.state.progressToken=e.progressToken,this.state.server=e.server,s(`[Progress] Initialized with token: ${e.progressToken}`)}setTotalTests(e){this.state.totalTests=e,s(`[Progress] Updated totalTests to: ${e}`)}notify(e,t,r){if(!this.state.progressToken||!this.state.server){s("[Progress] No token or server available, skipping notification");return}let i={progressToken:this.state.progressToken,progress:e,total:t,...r&&{message:r}};s(`[Progress] Notifying: ${e}/${t} - ${r||"no message"}`),this.state.server.notification({method:"notifications/progress",params:i}).catch(o=>{s(`[Progress] Failed to send notification: ${o}`)})}toolCalled(){this.notify(1,100,"Tool called")}toolValidated(){this.notify(2,100,"Tool validation completed")}evaluateStarted(){this.notify(3,100,"Evaluation started")}asyncPrepInitiated(){this.notify(4,100,"Async preparation initiated")}updateAsyncPreparationProgress(e,t){let r=Math.round(5+e/100*15),i=t||`Execution progress: ${e}%`;s(`[Progress] Execution progress ${e}% \u2192 ${r}%`),this.notify(r,100,i)}testsExecutionStarted(){this.notify(20,100,"Test execution started")}incrementCompletedTests(e){if(!this.state.totalTests){s("[Progress] Cannot increment completed tests - totalTests not set");return}this.state.completedTests++;let t=this.state.completedTests/this.state.totalTests,r=Math.round(Math.min(20+t*79,99));s(`[Progress] Test ${this.state.completedTests}/${this.state.totalTests} completed \u2192 ${r}% (testsProgress: ${t.toFixed(3)})`);let i=e||`Test ${this.state.completedTests}/${this.state.totalTests} completed`;this.notify(r,100,i)}complete(){s("[Progress] Evaluation completed, cleaning up (no final notification sent)"),this.cleanup()}fail(e){this.notify(99,100,`Evaluation failed: ${e||"unknown error"}`)}completeAfterFailure(){s("[Progress] Failed evaluation completed, cleaning up (no final notification sent)"),this.cleanup()}cleanup(){this.state={progressToken:void 0,server:void 0,totalTests:0,completedTests:0}}},A=new xe;var Xe=3e4,xt=2e3,_t=3,z=class n{static{d(this,"ApiClient")}#e;#t;static apiCalls={initialize:0,async_prep:0,execution_state:0,step:0};constructor(e,t){this.#e=e,this.#t=t}get baseUrl(){return this.#e}async#s(e,t,r){let{timeoutMs:i=Xe,context:o}=r,a=typeof e=="string"?e:e instanceof URL?e.href:e.url;s(`[API FETCH] \u{1F535} BEFORE | URL: ${a} | Method: ${t.method||"GET"} | Context: ${o}`);try{let p=this.#t??t.signal;if(i){let u=AbortSignal.timeout(i);p=p?AbortSignal.any([p,u]):u}let l=await fetch(e,{...t,signal:p});if(s(`[API FETCH] \u{1F7E2} AFTER | URL: ${a} | Status: ${l.status} | OK: ${l.ok}`),this.#t?.aborted)throw s(`[API FETCH] \u{1F534} ABORTED | URL: ${a} | Context: ${o}`),new Error(`API call aborted: ${o}`);if(!l.ok)throw s(`[API FETCH] \u{1F534} ERROR | URL: ${a} | Status: ${l.status} | Context: ${o}`),new Error(`${o} failed: ${l.status}`);let g=await l.json();if(!g)throw s(`[API FETCH] \u{1F534} ERROR | URL: ${a} | json() returned undefined`),new Error(`API call failed, json() returned undefined: ${o}`);return s(`[API FETCH] \u2705 SUCCESS | URL: ${a} | Context: ${o}`),g}catch(p){throw s(`[API FETCH] \u274C EXCEPTION | URL: ${a} | Context: ${o} | Error: ${E(p)}`),p}}async#r(e,t,r){let{maxRetries:i=_t,baseDelay:o=xt,timeoutMs:a=Xe,context:p}=r,l,g=0;for(let u=0;u<=i;u++)try{return await this.#s(e,t,{timeoutMs:a,context:p})}catch(m){if(l=m,Ae(m)&&(g++,this.#t?.aborted))throw m;let h=m.message?.match(/failed: (\d+)/i);if(h){let w=parseInt(h[1]);if(![408,429,500,502,503,504].includes(w))throw m}if(u===i)throw s(`[ApiClient] ${p} failed after ${i+1} attempts. Last error: ${l.message}`),g===i+1?new Error(`Server not responding. Request timed out after ${a/1e3} seconds and was retried ${i} times. Test aborted. `):l;let y=o*Math.pow(2,u);s(`[ApiClient] ${p} attempt ${u+1} failed: ${l.message}. Retrying in ${y}ms...`),await new Promise(w=>setTimeout(w,y))}throw l}async asyncPrep(e){let t=`api-async-prep-${++n.apiCalls.async_prep}-${Date.now()}`;c.start("api-async-prep",{uid:t});let r=await this.#s(`${this.baseUrl}/mgr/api/v1/test-plans/async_prep`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)},{context:"Async QA sessions preparation",timeoutMs:6e4});return c.end("api-async-prep",{uid:t,runId:r.execution_id}),r}async getExecutionState(e){let t=`api-get-execution-state-${++n.apiCalls.execution_state}-${Date.now()}`,r=`${this.baseUrl}/mgr/api/v1/executions/${e}/state`;s(`[ApiClient.getExecutionState] ${t} - Fetching state for runId: ${e}`),s(`[ApiClient.getExecutionState] ${t} - Request URL: ${r}`),c.start("api-get-execution-state",{uid:t,runId:e});let i=await this.#s(r,{method:"GET",headers:{"Content-Type":"application/json"}},{context:"Get execution state",timeoutMs:5e3});return s(`[ApiClient.getExecutionState] ${t} - Response status: ${i.status}`),c.end("api-get-execution-state",{uid:t,runId:e,status:i.status}),i}async asyncPrepWithStatePolling(e){let t=`api-async-prep-with-polling-${Date.now()}`;c.start("api-async-prep-with-polling",{uid:t});let{execution_id:r}=await this.asyncPrep(e);s(`[ApiClient] Started async prep with runId: ${r}`),A.asyncPrepInitiated();let i=Date.now(),o=10*60*1e3,a=3e3;for(;;){if(Date.now()-i>=o)throw new Error(`Preparing timeout: Test plan preparation exceeded ${o/(60*1e3)} minutes `);try{let l=await this.getExecutionState(r);switch(s(`[ApiClient] Poll ${r}: ${l.status} - ${l.message} (${l.progress_percentage}%)`),A.updateAsyncPreparationProgress(l.progress_percentage,`${l.message} (created ${l.completed_sessions} sessions)`),l.status){case"running":case"completed":{if(!l.sessions)throw s(`[ApiClient] ERROR: Status '${l.status}' but no sessions in state response`),new Error(`'${l.status}' but no sessions`);return s(`[ApiClient] Sessions data received: ${l.sessions.length} sessions`),{sessions:l.sessions,runId:r}}case"failed":throw new v({confidence:1,feedbacks:[{text:`UNACCEPTABLE: Failed to prepare test plan - ${l.message}. The .vibe/test_plan content appears to be invalid or insufficient.`,structured:{violation:"QA_PLAN_PREPARATION_FAILED",testId:"N/A",severity:"BLOCKING",penalty:"$2000"},suggestions:[{type:"action",content:`Review and fix the .vibe/test_plan file content. Error: ${l.message}`,severity:"BLOCKING"}]}]});case"preparing":break;default:throw new Error(`Unknown execution status: ${l.status}`)}}catch(l){if(l instanceof v)throw l;Ae(l)?s(`[ApiClient] Poll timeout for ${r}, retrying...`):s(`[ApiClient] Poll error for ${r}: ${E(l)}
retrying...`)}finally{c.end("api-async-prep-with-polling",{uid:t,runId:r})}await new Promise(l=>setTimeout(l,a))}}async step(e,t){let r=`api-step-${++n.apiCalls.step}-${Date.now()}`;c.start("api-step",{uid:r,sessionId:e});let i=Math.random().toString(36).substring(2,15),o=`${this.baseUrl}/${e}/step?rand=${i}`,a=await this.#r(o,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)},{context:`[${e}] QA step`,timeoutMs:6e4});return c.end("api-step",{uid:r,sessionId:e,action:a.action}),a}async abort(e){await this.#s(`${this.baseUrl}/${e}/abort`,{method:"POST",headers:{"Content-Type":"application/json"}},{context:`[${e}] Session abort`})}async initializeTool(e){let t=`api-init-tool-${++n.apiCalls.initialize}-${Date.now()}`;c.start("api-init-tool",{uid:t});let r=await this.#s(`${this.baseUrl}/init_tool`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)},{context:"Tool initialization"});return c.end("api-init-tool",{uid:t,result:"success"}),r}async initializeMcpConfig(e){let t=`api-init-mcp-config-${++n.apiCalls.initialize}-${Date.now()}`;c.start("api-init-mcp-config",{uid:t});let r=await this.#s(`${this.baseUrl}/mcp_config`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)},{context:"MCP configuration initialization"});return c.end("api-init-mcp-config",{uid:t,result:"success"}),r}};var ge=class{static{d(this,"EvaluatorTool")}tools=new Map;commands=[];initPromise=null;async init(e){return this.tools.size>0?{tools:Array.from(this.tools.values()),commands:this.commands}:this.initPromise?this.initPromise:(s("=== [EvaluatorTool] Fetching MCP configuration ==="),this.initPromise=this.#e(e),this.initPromise)}async getAll(e){let{tools:t}=await this.init(e);return t}async get(e,t){return(await this.getAll(e)).find(i=>i.name===t)}async#e(e){try{let t=await new z(e).initializeMcpConfig({os:ue(),coding_platform:Ge(),coding_agent:"claude-4-sonnet"});for(let r of t.tools){let i={name:r.name,description:r.description,inputSchema:JSON.parse(r.schema)};this.tools.set(i.name,i),s(`[EvaluatorTool] Loaded tool: ${i.name}`)}return this.commands=t.commands,s("=== [EvaluatorTool] MCP configuration fetched successfully ==="),s(`Tools count: ${this.tools.size}`),s(`Commands count: ${this.commands.length}`),{tools:Array.from(this.tools.values()),commands:this.commands}}catch(t){throw s("[EvaluatorTool] Error fetching MCP configuration:"),s(E(t)),this.initPromise=null,t}}};import{spawn as Dt}from"child_process";import Ot from"net";var Ze=d(n=>{let e=[/Local:\s*(https?:\/\/[^\sâ”‚\u2502\u2500]+)/i,/url:\s*(https?:\/\/[^\s]+)/i,/Local:\s*(https?:\/\/localhost:\d+)/i,/Serving HTTP.*?port\s+(\d+)/i,/(?:server.*?(?:running|started).*?(?:on|at)|listening.*?(?:on|at)).*?(https?:\/\/[^\s]+)/i,/(https?:\/\/localhost:\d+)/i,/(https?:\/\/0\.0\.0\.0:\d+)/i,/(?:port|listening.*?on).*?(\d+)/i];for(let t of e){let r=n.match(t);if(r){let i=r[1];if(/^\d+$/.test(i)&&(i=`http://localhost:${i}`),i.includes("0.0.0.0")&&(i=i.replace("0.0.0.0","localhost")),i.startsWith("http://")||i.startsWith("https://"))return i}}return null},"extractUrlFromOutput");var re=class{static{d(this,"WebappController")}#e;async#t(e){let t=e||Math.floor(Math.random()*5e4)+1e4,r=100;for(let i=0;i<r;i++){let o=t+i;if(o>65535)continue;if(await this.#s(o))return s(`[WebappController] Found available port: ${o}`),o}throw new Error(`Failed to find available port after ${r} attempts starting from ${t}`)}async#s(e){return new Promise(t=>{let r=Ot.createServer();r.once("error",i=>{i.code,t(!1)}),r.once("listening",()=>{r.close(),t(!0)}),r.listen(e,"0.0.0.0")})}async#r(e){let t=e.trim();return t.match(/^open\s+(.+\.html?)$/i)?(s("[WebappController] Detected 'open' command for HTML file, converting to HTTP server"),`npx --yes serve -l ${await this.#t()}`):t==="open"||t==="open ."?(s("[WebappController] Detected generic 'open' command, converting to HTTP server"),`npx --yes serve -l ${await this.#t()}`):t.match(/^[^/\s]+\.html?$/i)?(s("[WebappController] Detected bare HTML filename, converting to HTTP server"),`npx --yes serve -l ${await this.#t()}`):e}startWebapp=d(async(e,t)=>{let r=`webapp-start-${Date.now()}`;c.start("webapp-start",{uid:r,command:t});let i=await this.#r(t);return i!==t&&s(`[WebappController] Transformed command from "${t}" to "${i}"`),new Promise((o,a)=>{s(`[WebappController] Starting webapp with command "${i}" in ${e}`);try{let p,l;if(i.startsWith("node -e")){let w=i.match(/^node -e\s+(.+)$/);if(w){let b=w[1],_=b.startsWith('"')&&b.endsWith('"')?b.slice(1,-1):b;p="node",l=["-e",_]}else throw c.end("webapp-start",{uid:r,result:"error",error:"Invalid node -e command"}),new Error(`Invalid node -e command: ${i}`)}else[p,...l]=i.split(" ");c.start("webapp-process-spawn",{uid:r,command:p});let g=Dt(p,l,{cwd:e,stdio:["pipe","pipe","pipe"]});c.end("webapp-process-spawn",{uid:r,command:p,result:"success",pid:g.pid});let u=null,m={};c.start("webapp-url-detection",{uid:r});let h=d((w,b={})=>{m.current&&(clearTimeout(m.current),m.current=null);let _=typeof w=="string"?w:w.message,C=typeof w=="string"?new Error(w):w;c.end("webapp-url-detection",{uid:r,result:"error",...b}),c.end("webapp-start",{uid:r,result:"error",error:_,...b}),a(C)},"handleError"),y=d(w=>{let b=Ze(w);b&&!u&&(u=b,s(`[WebappController] Detected webapp URL "${b}"`),this.#e={process:g,url:b},m.current&&(clearTimeout(m.current),m.current=null),c.end("webapp-url-detection",{uid:r,result:"success",detectedUrl:b}),c.end("webapp-start",{uid:r,result:"success",url:b}),o(this.#e))},"detectUrl");g.stdout?.on("data",w=>{let b=w.toString();s(`[WebappController] stdout: ${b}`),y(b)}),g.stderr?.on("data",w=>{let b=w.toString();s(`[WebappController] stderr: ${b}`),y(b)}),g.on("error",w=>{s("[WebappController] Error starting webapp process"),s(E(w)),h(w,{source:"process-error"})}),g.on("close",(w,b)=>{s(`Webapp process closed with code ${w} and signal ${b}`),w!==0&&!u&&h(`Webapp process exited with code ${w}`,{exitCode:w,signal:b})}),m.current=setTimeout(()=>{u||(m.current=null,h("Timeout: No webapp URL detected within 30 seconds",{source:"timeout"}))},3e4)}catch(p){c.end("webapp-start",{uid:r,result:"error",error:p.message}),a(p)}})},"startWebapp");stopWebapp=d(()=>new Promise(e=>{if(this.#e&&!this.#e.process.killed){let t=`webapp-stop-${Date.now()}`;c.start("webapp-stop",{uid:t}),s("[WebappController] Stopping webapp process");let r=this.#e.process,i=!1,o=d(()=>{i||(i=!0,c.end("webapp-stop",{uid:t,result:"success",pid:r.pid}),this.#e=void 0,global.gc&&global.gc(),e())},"cleanup");r.once("exit",o),r.kill("SIGTERM"),setTimeout(()=>{!r.killed&&!i&&(s("[WebappController] Process didn't exit gracefully, sending SIGKILL"),r.kill("SIGKILL"))},1e3),setTimeout(()=>{i||(s("[WebappController] Force resolving after timeout"),o())},3e3)}else this.#e=void 0,e()}),"stopWebapp");get webapp(){return this.#e}};import et from"fs";var he=d(async n=>{let e=`webapp-validation-${Date.now()}`;if(n.startsWith("file:///")){c.start("webapp-file-validation",{uid:e,url:n});let t=n.replace("file://",""),{access:r}=et.promises;await r(t,et.constants.F_OK),c.end("webapp-file-validation",{uid:e,result:"success",filePath:t}),s(`[validateWebappUrl] Confirmed file exists at ${n}`)}else{c.start("webapp-http-validation",{uid:e,url:n});let t=new AbortController,r=setTimeout(()=>t.abort(),2e3),i=await fetch(n,{method:"HEAD",signal:t.signal});if(clearTimeout(r),!i.ok){let o=new Error(`Server responded with status ${i.status}`);throw c.end("webapp-http-validation",{uid:e,result:"error",httpStatus:i.status,error:o.message}),o}s(`[validateWebappUrl] Confirmed server is running at ${n}`),c.end("webapp-http-validation",{uid:e,result:"success",httpStatus:i.status})}},"validateWebappUrl");import it from"path";import ie from"fs";import{randomUUID as Ft}from"node:crypto";import{cpus as Ut,freemem as Mt,totalmem as Vt}from"node:os";import{execSync as zt}from"node:child_process";import Nt from"path";import kt from"fs";import{parse as tt}from"csv-parse";var _e=d(async(n,e,t)=>(s("[filterTestPlanCSV] Starting CSV filtering..."),s(`[filterTestPlanCSV] testIndex: ${e}, testId: ${t}`),s(`[filterTestPlanCSV] CSV content length: ${n.length}`),new Promise((r,i)=>{let o=[],a,p=0,l=0,g=!1,u;s("[filterTestPlanCSV] Initializing CSV parser...");let m=tt({delimiter:"|",skip_empty_lines:!0,trim:!0});m.on("readable",function(){let h;for(;h=m.read();){if(s(`[filterTestPlanCSV] Parsing row: ${JSON.stringify(h)}`),typeof h[0]=="string"&&h[0].startsWith("#")){s(`[filterTestPlanCSV] Found header row: ${JSON.stringify(h)}`),a=h;continue}if(p++,l++,s(`[filterTestPlanCSV] Processing data row ${p}: ${JSON.stringify(h)}`),e&&p===e)s(`[filterTestPlanCSV] Found target row by index ${e}: ${JSON.stringify(h)}`),u=h,g=!0;else if(t&&h.length>0){let y=h[0]?.trim();s(`[filterTestPlanCSV] Checking testId: "${y}" vs target "${t}"`),y===t&&(s(`[filterTestPlanCSV] Found target row by testId "${t}": ${JSON.stringify(h)}`),u=h,g=!0)}}}),m.on("error",function(h){s(`[filterTestPlanCSV] Error parsing CSV: ${h.message}`),i(h)}),m.on("end",function(){if(s("[filterTestPlanCSV] ========== CSV parser 'end' event triggered =========="),s(`[filterTestPlanCSV] foundTest: ${g}`),s(`[filterTestPlanCSV] targetRow exists: ${!!u}`),s(`[filterTestPlanCSV] headerRow exists: ${!!a}`),!g||!u){e?s(`[filterTestPlanCSV] Test index ${e} not found in ${l} total tests`):t&&s(`[filterTestPlanCSV] Test ID "${t}" not found in ${l} total tests`),s("[filterTestPlanCSV] Returning failure result with original CSV"),r({filteredCSV:n,found:!1,originalTestCount:l,filteredTestCount:0});return}let h=[];a&&(h.push(a.join("|")),s(`[filterTestPlanCSV] Added header row: ${a.join("|")}`)),u&&(h.push(u.join("|")),s(`[filterTestPlanCSV] Added target row: ${u.join("|")}`));let y=h.join(`
`);e?s(`[filterTestPlanCSV] \u2705 Successfully filtered CSV to test index ${e}`):t&&s(`[filterTestPlanCSV] \u2705 Successfully filtered CSV to test ID "${t}"`),s(`[filterTestPlanCSV] Filtered CSV content (length: ${y.length}):
${y}`),s("[filterTestPlanCSV] ========== Resolving promise with success result =========="),r({filteredCSV:y,found:!0,originalTestCount:l,filteredTestCount:1})}),s(`[filterTestPlanCSV] Writing CSV content to parser (${n.length} characters)...`),m.write(n),s("[filterTestPlanCSV] Calling parser.end()..."),m.end()})),"filterTestPlanCSV"),De=d(async(n,e)=>(s("[filterTestPlanByTestIds] Starting CSV filtering for multiple testIds..."),s(`[filterTestPlanByTestIds] testIds: ${JSON.stringify(e)}`),s(`[filterTestPlanByTestIds] CSV content length: ${n.length}`),new Promise((t,r)=>{let i,o=[],a=[],p=new Set(e),l=0;s("[filterTestPlanByTestIds] Initializing CSV parser...");let g=tt({delimiter:"|",skip_empty_lines:!0,trim:!0});g.on("readable",function(){let u;for(;u=g.read();){if(s(`[filterTestPlanByTestIds] Parsing row: ${JSON.stringify(u)}`),typeof u[0]=="string"&&u[0].startsWith("#")){s(`[filterTestPlanByTestIds] Found header row: ${JSON.stringify(u)}`),i=u;continue}l++;let m=u[0]?.trim();s(`[filterTestPlanByTestIds] Processing data row ${l}, testId: "${m}"`),m&&p.has(m)&&(s(`[filterTestPlanByTestIds] \u2705 Match found for testId "${m}"`),o.push(u),a.push(m))}}),g.on("error",function(u){s(`[filterTestPlanByTestIds] Error parsing CSV: ${u.message}`),r(u)}),g.on("end",function(){s("[filterTestPlanByTestIds] ========== CSV parser 'end' event triggered =========="),s(`[filterTestPlanByTestIds] Total data rows: ${l}`),s(`[filterTestPlanByTestIds] Matched rows: ${o.length}`),s(`[filterTestPlanByTestIds] Found testIds: ${JSON.stringify(a)}`);let u=e.filter(y=>!a.includes(y));s(`[filterTestPlanByTestIds] Not found testIds: ${JSON.stringify(u)}`);let m=[];i&&(m.push(i.join("|")),s("[filterTestPlanByTestIds] Added header row"));for(let y of o)m.push(y.join("|"));let h=m.join(`
`)+`
`;s(`[filterTestPlanByTestIds] Filtered CSV length: ${h.length}`),s("[filterTestPlanByTestIds] ========== Resolving promise with result =========="),t({filteredCSV:h,originalTestCount:l,filteredTestCount:o.length,foundTestIds:a,notFoundTestIds:u})}),s(`[filterTestPlanByTestIds] Writing CSV content to parser (${n.length} characters)...`),g.write(n),s("[filterTestPlanByTestIds] Calling parser.end()..."),g.end()})),"filterTestPlanByTestIds");var we=d(n=>{let e=Nt.join(n,".vibe","test_plan");return kt.readFileSync(e,"utf8")},"readTestPlanRaw"),st=d(async n=>{try{let e=we(n);if(!(await G(e)).isValid)return s("[assertTestPlanFile] Returning CRITIQUE - Invalid or empty test plan file"),new v({confidence:1,feedbacks:[{text:"UNACCEPTABLE: Empty or invalid test plan in .vibe/test_plan file. FORBIDDEN to continue without a detailed test plan for the entire project.",structured:{violation:"MANDATORY_QA_PLAN",testId:"N/A",severity:"BLOCKING",penalty:"$2000"},suggestions:[{type:"action",content:"RULE 1: Create comprehensive QA test plan in CSV format in .vibe/test_plan file covering the entire project. NO SHORTCUTS.",severity:"BLOCKING"}]}]});s("[assertTestPlanFile] Test plan file validated successfully");return}catch(e){let t=e.message.toLowerCase();return t.includes("enoent")||t.includes("no such file")?(s("[assertTestPlanFile] Returning CRITIQUE - Missing .vibe/test_plan file"),new v({confidence:1,feedbacks:[{text:"UNACCEPTABLE: Missing .vibe/test_plan file. FORBIDDEN to continue without a detailed test plan for the entire project.",structured:{violation:"MANDATORY_QA_PLAN",testId:"N/A",severity:"BLOCKING",penalty:"$2000"},suggestions:[{type:"action",content:"RULE 1: Create comprehensive QA test plan in .vibe/test_plan file covering the entire project. Step-by-step instructions. NO SHORTCUTS.",severity:"BLOCKING"}]}]})):(s("[assertTestPlanFile] Returning CRITIQUE - Error reading .vibe/test_plan file"),new v({confidence:1,feedbacks:[{text:`UNACCEPTABLE: Error reading .vibe/test_plan file: ${t}! FORBIDDEN to continue without accessible test plan.`,structured:{violation:"QA_PLAN_ACCESS_ERROR",testId:"N/A",severity:"BLOCKING",penalty:"$2000"},suggestions:[{type:"action",content:`Ensure .vibe/test_plan file exists and is readable. Error: ${t}`,severity:"BLOCKING"}]}]}))}},"assertTestPlanFile");import Lt from"path";import Bt from"fs";var Oe=d(n=>{let e=Lt.join(n,".vibe","user_flows");try{return Bt.readFileSync(e,"utf8")}catch(t){let r=t.message.toLowerCase();if(r.includes("enoent")||r.includes("no such file"))return s("[readUserFlowsRaw] User flows file not found, returning empty content"),"";throw t}},"readUserFlowsRaw"),rt=d(async n=>{try{let e=Oe(n);if(!e.trim()){s("[assertUserFlowsFile] User flows file not found or empty, continuing without user flows");return}if(!(await G(e)).isValid)return s("[assertUserFlowsFile] Returning CRITIQUE - Invalid user flows file format"),new v({confidence:1,feedbacks:[{text:"Invalid user flows format in .vibe/user_flows file. Please provide valid CSV format or remove the file to proceed without user flows.",structured:{violation:"INVALID_USER_FLOWS_FORMAT",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:"Fix the CSV format in .vibe/user_flows file or remove the file to proceed without user flows documentation.",severity:"HIGH"}]}]});s("[assertUserFlowsFile] User flows file validated successfully");return}catch(e){let t=e.message.toLowerCase();if(t.includes("enoent")||t.includes("no such file")){s("[assertUserFlowsFile] User flows file not found, continuing without user flows");return}return s("[assertUserFlowsFile] Returning CRITIQUE - Error reading .vibe/user_flows file"),new v({confidence:1,feedbacks:[{text:`Error reading .vibe/user_flows file: ${t}. Please fix the file permissions or remove the file to proceed without user flows.`,structured:{violation:"USER_FLOWS_ACCESS_ERROR",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:`Fix file permissions for .vibe/user_flows or remove the file to proceed without user flows. Error: ${t}`,severity:"HIGH"}]}]})}},"assertUserFlowsFile");var Ht=d(n=>/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(n.trim()),"isValidUUID"),nt=d(n=>{let e=it.join(n,".vibe"),t=it.join(e,"uid");ie.existsSync(e)||ie.mkdirSync(e,{recursive:!0});let r;try{if(ie.existsSync(t)){let i=ie.readFileSync(t,"utf8").trim();if(Ht(i))return i;s(`[readAppUID] Invalid UUID found in ${t}, replacing with new one`)}return r=Ft(),ie.writeFileSync(t,r,"utf8"),s(`[readAppUID] Generated new app UID: ${r}`),r}catch(i){throw s("[readAppUID] Error reading UID:"),s(E(i)),i}},"readAppUID"),ot=d(async n=>Qt(n.projectFolderPath)??jt(n)??await Gt(n)??await st(n.projectFolderPath)??await rt(n.projectFolderPath)??await Wt(n)??await qt(n),"assertEvaluationRequest"),Qt=d(n=>{if(!n)return s("[assertEvaluationRequest] Returning CRITIQUE - Missing project folder path"),new v({confidence:1,feedbacks:[{text:"UNACCEPTABLE: Missing projectFolderPath. FORBIDDEN to proceed without project path.",structured:{violation:"MANDATORY_PROJECT_PATH",testId:"N/A",severity:"BLOCKING",penalty:"$1000"},suggestions:[{type:"action",content:`RULE 1: Provide the absolute path to the project folder (e.g., '/path/to/project').
                                NO EXCEPTIONS.`,severity:"HIGH"}]}]})},"assertProjectFolderPath"),jt=d(n=>{let{projectRunCommand:e,projectRunUrl:t}=n;if(!t&&!e)return s("[assertEvaluationRequest] Returning CRITIQUE - Missing project run command"),new v({confidence:1,feedbacks:[{text:"UNACCEPTABLE: Missing projectRunCommand. FORBIDDEN to proceed without run command or running server address.",structured:{violation:"MANDATORY_PROJECT_RUN_COMMAND",testId:"N/A",severity:"BLOCKING",penalty:"$1000"},suggestions:[{type:"action",content:`RULE 2: Either provide the run command to start the project locally (e.g., 'yarn dev' or 'npm start') OR provide the projectRunUrl of an already running server.
                            NO EXCEPTIONS.`,severity:"HIGH"}]}]})},"assertProjectRunCommand"),Gt=d(async n=>{let{projectRunUrl:e}=n;if(e){if(!/^(https?|file):\/\/\S*$/.test(e))return s("[assertEvaluationRequest] Returning CRITIQUE - Invalid project run address format"),new v({confidence:1,feedbacks:[{text:`UNACCEPTABLE: Invalid projectRunUrl format '${e}'. Must be a valid HTTP/HTTPS/FILE URL.`,structured:{violation:"INVALID_PROJECT_RUN_ADDRESS",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:"Provide a valid URL format for projectRunUrl (e.g., 'http://localhost:3000', 'https://localhost:8080', 'file:///path/to/file.html').",severity:"HIGH"}]}]});try{await he(e)}catch(r){return s("validateWebappUrl Error:"),s(E(r)),new v({confidence:1,feedbacks:[{text:`UNACCEPTABLE: Unaccessible projectRunUrl '${e}'.`,structured:{violation:"UNACCESSIBLE_PROJECT_RUN_ADDRESS",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:"Provide an accessible URL for projectRunUrl",severity:"HIGH"}]}]})}}},"assertProjectRunUrl"),Wt=d(async n=>{let{targetTests:e}=n;if(e){if(!Array.isArray(e))return s("[assertTargetTests] Returning CRITIQUE - targetTests must be an array"),new v({confidence:1,feedbacks:[{text:"UNACCEPTABLE: targetTests must be an array. FORBIDDEN to proceed with invalid format.",structured:{violation:"INVALID_TARGET_TESTS_FORMAT",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:"Provide targetTests as an array of objects with testId and context fields.",severity:"HIGH"}]}]});for(let t=0;t<e.length;t++){let r=e[t];if(!r||typeof r!="object")return s(`[assertTargetTests] Returning CRITIQUE - targetTests[${t}] must be an object`),new v({confidence:1,feedbacks:[{text:`UNACCEPTABLE: targetTests[${t}] must be an object. FORBIDDEN to proceed with invalid format.`,structured:{violation:"INVALID_TARGET_TEST_ITEM",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:"Each targetTest item must be an object with testId and context fields.",severity:"HIGH"}]}]});if(!r.testId||typeof r.testId!="string")return s(`[assertTargetTests] Returning CRITIQUE - targetTests[${t}].testId must be a string`),new v({confidence:1,feedbacks:[{text:`UNACCEPTABLE: targetTests[${t}].testId must be a string. FORBIDDEN to proceed without valid testId.`,structured:{violation:"MISSING_TARGET_TEST_ID",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:"Provide a valid testId string that matches a testId in test_plan.",severity:"HIGH"}]}]});if(!r.context||typeof r.context!="string")return s(`[assertTargetTests] Returning CRITIQUE - targetTests[${t}].context must be a string`),new v({confidence:1,feedbacks:[{text:`UNACCEPTABLE: targetTests[${t}].context must be a string. FORBIDDEN to proceed without context.`,structured:{violation:"MISSING_TARGET_TEST_CONTEXT",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:"Provide a context string explaining why this test is being re-run.",severity:"HIGH"}]}]})}s(`[assertTargetTests] Validated ${e.length} target tests structure successfully`)}},"assertTargetTests"),qt=d(async n=>{let{testIds:e}=n;if(e){if(!Array.isArray(e))return s("[assertTestIds] Returning CRITIQUE - testIds must be an array"),new v({confidence:1,feedbacks:[{text:"UNACCEPTABLE: testIds must be an array. FORBIDDEN to proceed with invalid format.",structured:{violation:"INVALID_TEST_IDS_FORMAT",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:"Provide testIds as an array of strings (test ID values).",severity:"HIGH"}]}]});for(let t=0;t<e.length;t++){let r=e[t];if(!r||typeof r!="string")return s(`[assertTestIds] Returning CRITIQUE - testIds[${t}] must be a string`),new v({confidence:1,feedbacks:[{text:`UNACCEPTABLE: testIds[${t}] must be a non-empty string. FORBIDDEN to proceed with invalid testId.`,structured:{violation:"INVALID_TEST_ID_ITEM",testId:"N/A",severity:"BLOCKING",penalty:"$500"},suggestions:[{type:"action",content:"Provide valid testId strings in the testIds array.",severity:"HIGH"}]}]})}s(`[assertTestIds] Validated ${e.length} testIds successfully`)}},"assertTestIds"),at=d(n=>{let e=n.filter(({result:r,error:i})=>i||r?.decision!=="PASS");if(e.length){let r=e.map(({result:a,error:p})=>a||p?.toEvaluationResult()),i=r.flatMap(a=>a.feedbacks||[]).filter(a=>!!a?.text?.trim()||!!a.structured?.violation);return{decision:"CRITIQUE",confidence:Math.max(...r.map(a=>a.confidence)),feedbacks:i,metadata:{parallelExecutions:n.length}}}let t=n.flatMap(({result:r})=>r.feedbacks||[]).filter(r=>!!r?.text?.trim());return{decision:"PASS",confidence:n.length>0?Math.min(...n.map(({result:r})=>r.confidence)):0,feedbacks:t,metadata:{parallelExecutions:n.length}}},"aggregateTestResults");function lt(n=6){try{let e=Ut().length,t=Math.round(Vt()/1024/1024),r=Math.round(Mt()/1024/1024),i=ue(),o=1/0;try{if(i!=="windows"){let m=zt("ulimit -n",{encoding:"utf8",timeout:1e3}).trim(),h=parseInt(m);!isNaN(h)&&h>0&&(o=Math.floor(h/60),s(`[calculateOptimalParallelInstances] File descriptor limit: ${h}, allowing ~${o} instances`))}}catch(m){s(`[calculateOptimalParallelInstances] Could not check file descriptor limits: ${m}`)}let a=150,p;if(r<2048){let m;t<=8192?m=800:t<=16384?m=1200:t<=32768?m=1800:m=2400,p=Math.max(1,Math.min(Math.floor(m/a),10)),s(`[calculateOptimalParallelInstances] Memory pressure detected (${r}MB free), using tiered allocation: ${m}MB available for ${t}MB system`)}else{let m=Math.min(2048,Math.max(1024,r*.2)),h=Math.max(0,r-m);p=Math.floor(h/a)}let l=Math.max(1,Math.min(Math.floor(e*2),14)),g;switch(i){case"macos":g=Math.min(e*2+4,16);break;case"linux":g=Math.min(e*2+6,18);break;case"windows":g=Math.min(e*2,12);break;default:g=Math.min(e*2,12)}let u=Math.max(1,Math.min(p,l,g,o,16));return s(`[calculateOptimalParallelInstances] System info: ${e} CPUs, ${t.toLocaleString()}MB total RAM, ${r.toLocaleString()}MB free RAM, OS: ${i}`),s(`[calculateOptimalParallelInstances] Memory calculation: Per instance ${a}MB, Memory-based limit: ${p}`),s(`[calculateOptimalParallelInstances] Calculated limits - Memory: ${p}, CPU: ${l}, Platform: ${g}, FD: ${o===1/0?"unlimited":o}`),s(`[calculateOptimalParallelInstances] Selected optimal instances: ${u}`),u}catch(e){return s(`[calculateOptimalParallelInstances] Error calculating optimal instances: ${e}`),s(`[calculateOptimalParallelInstances] Falling back to default: ${n}`),n}}d(lt,"calculateOptimalParallelInstances");var Ne=d((n,e,t)=>({sessionUid:n.session_uid,currentStep:e,totalSteps:n.test_steps.length,taskName:n.test_name,taskDescription:n.test_description,testId:n.test_id,stepDescriptions:n.test_steps.map((r,i)=>typeof r.action=="string"?r.action:(s(`[buildDashboardSession] WARNING: Step ${i} action is not a string, converting: ${JSON.stringify(r.action)}`),String(r.action||"Unknown action"))),lastUpdate:Date.now(),screenshot:t}),"toDashboardSessionUpdate"),ct=d(n=>{for(let e=0;e<n.length;e++){let t=n[e];if(!t.session_uid)throw new Error(`No session uid found in session ${e}`);if(!t.test_id)throw new Error(`No test ID found in session ${t.session_uid}`);if(!t.test_name&&!t.test_description)throw new Error(`No test name nor description found in session ${t.session_uid}`);if(!t.test_steps?.filter(r=>(r&&typeof r.action!="string"&&s(`[assertQASessions] Invalid action type in session ${t.session_uid}: action=${JSON.stringify(r.action)}, step=${JSON.stringify(r)}`),r?.action&&typeof r.action=="string"&&r.action.trim().length>0)).length)throw new Error(`No valid test steps found in session ${t.session_uid}`)}},"assertQASessions");import*as F from"path";import*as ve from"fs";import{fileURLToPath as Jt}from"url";import Kt from"puppeteer";var dt=d((n,e)=>{s(`[fromQASessionToDashboardSession] session: ${n.session_uid}, test_steps: ${JSON.stringify(n.test_steps)}`);let t=n.test_steps.map((r,i)=>(s(`[fromQASessionToDashboardSession] Step ${i}: ${JSON.stringify(r)}`),s(`[fromQASessionToDashboardSession] Step ${i} action type: ${typeof r.action}, value: ${JSON.stringify(r.action)}`),typeof r.action=="string"?r.action:(s(`[fromQASessionToDashboardSession] WARNING: Step ${i} action is not a string, converting: ${JSON.stringify(r.action)}`),String(r.action||"Unknown action"))));return{sessionUid:n.session_uid,position:e,status:"pending",taskName:n.test_name,taskDescription:n.test_description,testId:n.test_id,currentStep:0,totalSteps:n.test_steps.length,stepDescriptions:t,lastUpdate:Date.now()}},"fromQASessionToDashboardSession");var Yt=Jt(import.meta.url),pt=F.dirname(Yt),k,S,ye;var H={maxRetries:3,retryDelay:1e3,recoveryDelay:500},mt=d(n=>{let e=n;for(;e!==F.dirname(e);){let t=F.join(e,"package.json");if(ve.existsSync(t))return e;e=F.dirname(e)}return process.cwd()},"findProjectRoot");async function Xt(){try{if(s("\u{1F504} Attempting to recover dashboard page connection..."),!k||!k.isConnected())return s("\u274C Dashboard browser is disconnected, cannot recover"),!1;let e=(await k.pages()).find(o=>!o.isClosed());if(e)return S=e,s("\u2705 Recovered dashboard page connection"),!0;let t=mt(pt),i=`file://${F.join(t,"src/dashboard/index.html")}`;return S=await k.newPage(),await S.goto(i),S.on("console",async o=>{let a=o.text();if((a.includes("EXTERNAL_URL_REQUEST")||a.includes("Opening external app dashboard"))&&s(`[Dashboard Console] ${a}`),a.startsWith("EXTERNAL_URL_REQUEST:")){let p=a.replace("EXTERNAL_URL_REQUEST:","").trim();s(`[Dashboard] Opening external URL in system browser: ${p}`);let{default:l}=await import("open");try{await l(p),s(`[Dashboard] Successfully opened ${p} in system browser`)}catch(g){s(`[Dashboard] Failed to open ${p}: ${g.message}`)}}}),await S.evaluate(()=>{window.__externalUrlHandlerRegistered||(window.__externalUrlHandlerRegistered=!0,window.addEventListener("openExternalUrl",o=>{console.log("EXTERNAL_URL_REQUEST:",o.detail.url)}))}),await new Promise(o=>setTimeout(o,H.recoveryDelay)),s(`\u2705 Created new dashboard page and navigated to ${i}`),!0}catch(n){return s(`\u274C Failed to recover dashboard page: ${n}`),!1}}d(Xt,"recoverDashboardPage");async function ne(n,e,t){let r=null;for(let i=1;i<=H.maxRetries;i++)try{return await n()}catch(o){r=o;let a=t?` for session ${t}`:"";if(s(`\u26A0\uFE0F Dashboard error in ${e}${a} (attempt ${i}/${H.maxRetries}): ${r.message}`),i===H.maxRetries){s(`\u274C Max retries reached for ${e}${a}`);break}if(!await Xt()){s(`\u274C Failed to recover dashboard page, stopping retries for ${e}${a}`);break}await new Promise(l=>setTimeout(l,H.retryDelay)),s(`\u{1F504} Retrying ${e}${a} (attempt ${i+1}/${H.maxRetries})`)}if(r){let i=t?` for session ${t}`:"";s(`\u274C Failed to execute ${e}${i} after ${H.maxRetries} attempts: ${r.message}`)}return null}d(ne,"executeWithRetry");var ft=d(async(n,e,t,r)=>{try{s(`\u{1F680} Opening Puppeteer dashboard with ${n.length} sessions`);let i=mt(pt),o=F.join(i,"dist/dashboard/index.html"),a=F.join(i,"src/dashboard/index.html"),p=ve.existsSync(o)?o:a;if(!ve.existsSync(p))throw new Error(`Dashboard HTML file not found at: ${p}`);if(k&&S)return s("\u{1F504} Reusing existing dashboard browser instance"),await ut(e,n,t,r);let l=`file://${p}`;return k=await Kt.launch({headless:!1,defaultViewport:null,protocolTimeout:0,args:["--no-sandbox","--disable-setuid-sandbox","--start-maximized","--app="+l,"--disable-web-security","--disable-features=VizDisplayCompositor","--disable-background-timer-throttling","--disable-renderer-backgrounding","--disable-backgrounding-occluded-windows","--disable-infobars","--disable-session-crashed-bubble","--disable-translate","--no-first-run","--disable-default-apps"]}),ye=V.register(k,"Dashboard-Browser"),S=(await k.pages())[0],S.on("console",async u=>{let m=u.text();if((m.includes("EXTERNAL_URL_REQUEST")||m.includes("Opening external app dashboard"))&&s(`[Dashboard Console] ${m}`),m.startsWith("EXTERNAL_URL_REQUEST:")){let h=m.replace("EXTERNAL_URL_REQUEST:","").trim();s(`[Dashboard] Opening external URL in system browser: ${h}`);let{default:y}=await import("open");try{await y(h),s(`[Dashboard] Successfully opened ${h} in system browser`)}catch(w){s(`[Dashboard] Failed to open ${h}: ${w.message}`)}}}),await S.evaluate(()=>{window.__externalUrlHandlerRegistered||(window.__externalUrlHandlerRegistered=!0,window.addEventListener("openExternalUrl",u=>{console.log("EXTERNAL_URL_REQUEST:",u.detail.url)}))}),k.on("disconnected",()=>{s("\u{1F534} Dashboard browser disconnected"),ye&&(V.unregister(ye),ye=void 0),k=void 0,S=void 0}),s(`\u2705 Dashboard opened in maximized app mode: file://${p}`),await ut(e,n,t,r)}catch(i){let o=i instanceof Error?i.message:String(i),a=i instanceof Error?i.stack:"";s(`\u274C Failed to open dashboard: ${o}`),s(`\u274C Dashboard error stack: ${a}`),console.error("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501"),console.error("\u26A0\uFE0F  DASHBOARD FAILED TO OPEN"),console.error("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501"),console.error(`Error: ${o}`),a&&console.error(`Stack: ${a}`),console.error("\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501"),console.error("The QA automation will continue without the dashboard UI."),console.error("To debug: check /tmp/mcp-evaluator-debug.log"),console.error(`\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501
`);return}},"openRealtimeBrowser");async function ut(n,e,t,r){if(s(`[initializeDashboardData] manual filter: ${n}, num of total sessions: ${e.length}`),!S)return;let i=n?await Zt(e):void 0;if(n&&!i?.length)throw new Error("Manual filter enabled, but no tests were selected");let o=i?.length?e.filter(l=>i.includes(l.test_id)):e;s(`[initializeDashboardData] num of filtered sessions: ${o.length}`);let a=o.map((l,g)=>dt(l,g));return await ne(async()=>{await S.evaluate((l,g,u)=>{window.dispatchEvent(new CustomEvent("dashboardInit",{detail:{sessions:l,appUid:g,apiUrl:u}}))},a,t,r)},"initializeDashboardData")!==null&&s(`\u{1F4CA} Dashboard initialized with ${a.length} sessions`),i}d(ut,"initializeDashboardData");async function Zt(n){if(S)try{s(`\u{1F3AF} Showing test filtering UI for ${n.length} tests`);let e=n.map(r=>({id:r.test_id,title:r.test_name||r.test_description})),t=await S.evaluate(`
            (function(tests) {
                return new Promise(function(resolve) {
                    console.log('\u{1F3AF} [PAGE] Starting filtering UI with ' + tests.length + ' tests');

                    // Dispatch event to show filtering UI
                    window.dispatchEvent(
                        new CustomEvent("showTestFilter", {
                            detail: { tests: tests },
                        })
                    );

                    console.log('\u23F3 [PAGE] Waiting for user selection...');

                    // Wait for user to make selection
                    var handleFilterComplete = function(event) {
                        var customEvent = event;
                        console.log(
                            '\u{1F389} [PAGE] Filter complete event received with IDs:',
                            customEvent.detail.selectedTestIds
                        );
                        window.removeEventListener("filterComplete", handleFilterComplete);
                        resolve(customEvent.detail.selectedTestIds);
                    };
                    window.addEventListener("filterComplete", handleFilterComplete);
                    console.log(
                        '\u{1F442} [PAGE] Event listener set up, waiting for filterComplete event'
                    );
                });
            })(${JSON.stringify(e)})
                `);return s(`\u2705 User selected ${t?.length||0} ${pe(t?.length||0,"test")}: ${t?.join(", ")||"none"}`),t}catch(e){s(`\u274C Failed to show test filtering UI: ${e}`);return}}d(Zt,"showTestFilteringUI");var gt=d(async n=>{if(!S)return;await ne(async()=>{await S.evaluate(t=>{window.dispatchEvent(new CustomEvent("dashboardRunning",{detail:{sessionUid:t}}))},n)},"markDashboardSessionRunning",n)!==null&&s(`\u{1F504} Dashboard session ${n} marked as running`)},"markDashboardSessionRunning"),ke=d(async n=>{if(!S){s(`\u26A0\uFE0F Dashboard not available for session ${n.sessionUid}`);return}await ne(async()=>{await S.evaluate(t=>{let r={sessionUid:t.sessionUid,status:"running",currentStep:t.currentStep,totalSteps:t.totalSteps,taskName:t.taskName,taskDescription:t.taskDescription,stepDescriptions:t.stepDescriptions,lastUpdate:Date.now(),testId:t.testId};window.dispatchEvent(new CustomEvent("dashboardUpdate",{detail:{sessionUid:t.sessionUid,data:r,screenshot:t.screenshot}}))},n)},"updateDashboardSession",n.sessionUid)!==null&&s(`\u{1F4C8} Dashboard updated for session ${n.sessionUid}`)},"updateDashboardSession"),Le=d(async(n,e)=>{if(!S)return;await ne(async()=>{await S.evaluate((r,i)=>{window.dispatchEvent(new CustomEvent("dashboardComplete",{detail:{sessionUid:r,result:i}}))},n,e)},"markDashboardSessionComplete",n)!==null&&s(`\u{1F3C1} Dashboard session ${n} marked as ${e.decision} (kept visible)`)},"markDashboardSessionComplete"),Be=d(async n=>{if(!S)return;await ne(async()=>{await S.evaluate(t=>{window.dispatchEvent(new CustomEvent("dashboardAborted",{detail:{sessionUid:t}}))},n)},"markDashboardSessionAborted",n)!==null&&s(`\u{1F6D1} Dashboard session ${n} marked as aborted`)},"markDashboardSessionAborted");import os from"p-limit";import fi from"puppeteer";import ht from"sharp";import be from"imghash";import{writeFileSync as oe,mkdirSync as es,unlinkSync as Ee}from"fs";import{resolve as $e}from"path";import{tmpdir as ts}from"os";import{join as wt}from"path";async function ss(n,e,t){s(`\u{1F4F8} Starting visual analysis for ${e.length} elements...`);let r=t?.["save-debug-screenshots"]??!1,i="";if(r){i=$e(process.cwd(),"debug");try{es(i,{recursive:!0}),s(`\u{1F4C1} Created debug directory: ${i}`)}catch(a){s(`\u{1F4C1} Debug directory already exists or creation failed: ${a}`)}}let o=0;for(let a of e)try{o++,s(`\u{1F4F8} Analyzing element ${o}/${e.length}: ${a.selector}`),await n.evaluate(l=>{let g=document.querySelector(l);g&&g.scrollIntoView({behavior:"instant",block:"center"})},a.selector),await new Promise(l=>setTimeout(l,100));let p=await n.screenshot({fullPage:!1,type:"png"});if(r){let l=$e(i,`element-${o.toString().padStart(2,"0")}-before.png`);oe(l,p)}try{await n.hover(a.selector),await new Promise(u=>setTimeout(u,300));let l=await n.screenshot({fullPage:!1,type:"png"});if(r){let u=$e(i,`element-${o.toString().padStart(2,"0")}-after.png`);oe(u,l),s(`\u{1F4BE} Saved screenshots: ${u.split("/").pop()}`)}let g=await rs(Buffer.from(p),Buffer.from(l),a.boundingBox);a.hoverAnalysis=g,await n.mouse.move(0,0),await new Promise(u=>setTimeout(u,100))}catch(l){s(`\u26A0\uFE0F Could not hover element ${a.selector}: ${l}`),a.hoverAnalysis={hasVisualChange:!1,changeScope:"none",changeIntensity:0,changesOutsideElement:!1,changeDescription:`Could not hover element: ${l}`}}}catch(p){s(`\u274C Error analyzing element ${a.selector}: ${p}`),a.hoverAnalysis={hasVisualChange:!1,changeScope:"none",changeIntensity:0,changesOutsideElement:!1,changeDescription:`Analysis failed: ${p}`}}if(r){let a=$e(i,"element-summary.txt"),p=e.map((l,g)=>{let u=(g+1).toString().padStart(2,"0"),m=l.hoverAnalysis?.hasVisualChange?"\u2705":"\u274C",h=l.hoverAnalysis?.changeIntensity||0;return`${u}. ${m} ${l.tagName.toUpperCase()} - ${l.selector} (${h}% change)`}).join(`
`);oe(a,p),s(`\u{1F4CB} Created element summary: ${a}`)}s(`\u2705 Visual analysis complete for ${o} elements`)}d(ss,"performHoverVisualAnalysis");async function rs(n,e,t){let r=await ns(n,e);if(r.totalChangedPixels===0)return{hasVisualChange:!1,changeScope:"none",changeIntensity:0,changesOutsideElement:!1,changeDescription:"No visual changes detected (pHash comparison)"};let i=Math.round(100-r.similarityPercentage),o=r.changesOutsideElement,a;i>0?a="element-only":a="none";let p=r.hammingDistance===-1?"byte comparison":"pHash (DCT)",l=r.hammingDistance!==-1?` (Hamming distance: ${r.hammingDistance})`:"",g=`${i}% perceptual change detected using ${p}${l}. ${o?"Changes detected outside element bounds.":"Changes confined to element area."}`;return{hasVisualChange:!0,changeScope:a,changeIntensity:i,changesOutsideElement:o,changeDescription:g}}d(rs,"analyzeVisualDifference");function is(n,e){if(n.length!==e.length)throw new Error("Hash lengths must be equal for Hamming distance calculation");let t=0;for(let r=0;r<n.length;r++)n[r]!==e[r]&&t++;return t}d(is,"hammingDistance");async function ns(n,e){try{if(n.equals(e)){s("\u{1F4F7} Images are byte-identical - no changes");let o=await ht(n).metadata();return{totalPixels:(o.width||0)*(o.height||0),totalChangedPixels:0,changesOutsideElement:!1,hammingDistance:0,similarityPercentage:100}}s("\u{1F50D} Images differ at byte level - running pHash analysis...");let t=ts(),r=wt(t,`phash_temp_1_${Date.now()}.png`),i=wt(t,`phash_temp_2_${Date.now()}.png`);try{oe(r,n),oe(i,e);let o=await be.hash(r,8,"hex"),a=await be.hash(i,8,"hex"),p=be.hexToBinary(o),l=be.hexToBinary(a);Ee(r),Ee(i);let g=is(p,l),u=p.length,m=(u-g)/u*100,h=100-m,y=await ht(n).metadata(),w=(y.width||0)*(y.height||0),b=Math.round(h/100*w),_=!1;return s("\u{1F50D} pHash (DCT) Analysis for element:"),s(`   \u{1F4CA} Hash 1 (hex): ${o}`),s(`   \u{1F4CA} Hash 2 (hex): ${a}`),s(`   \u{1F500} Binary 1: ${p.substring(0,20)}...`),s(`   \u{1F500} Binary 2: ${l.substring(0,20)}...`),s(`   \u{1F4CF} Hamming distance: ${g}/${u} bits`),s(`   \u{1F4C8} Similarity: ${m.toFixed(1)}%`),s(`   \u{1F4C9} Change: ${h.toFixed(1)}%`),s(`   \u{1F4F8} Image dimensions: ${y.width}x${y.height}`),{totalPixels:w,totalChangedPixels:b,changesOutsideElement:_,hammingDistance:g,similarityPercentage:m}}catch(o){try{Ee(r)}catch{}try{Ee(i)}catch{}throw o}}catch(t){s(`\u26A0\uFE0F pHash comparison failed, falling back to basic comparison: ${t}`);let r=Math.min(n.length,e.length),i=0;for(let a=0;a<r;a++)n[a]!==e[a]&&i++;let o=i/r*100;return{totalPixels:r,totalChangedPixels:i,changesOutsideElement:o>10,hammingDistance:-1,similarityPercentage:100-o}}}d(ns,"comparePixels");function yt(n){try{s(`\u{1F50D} DEBUG: DOM data type: ${typeof n}`);let e=n?.elements||[];s(`\u{1F50D} Found ${e.length} total elements in DOM`);let t=e.filter(i=>i.elementId&&i.elementId.trim()!=="");s(`\u{1F3AF} Found ${t.length} elements with elementId (data-qa-id)`);let r=t.map(i=>{let o=`[data-qa-id="${i.elementId}"]`;return{elementId:i.elementId,selector:o,bounds:{x:i.bounds?.left||0,y:i.bounds?.top||0,width:i.bounds?.width||0,height:i.bounds?.height||0},text:i.text||"",interaction:i.interaction||"unknown",hasHover:i.hasHover||!1}});return r.length>0?(s("\u{1F3AF} QA elements for hover analysis:"),r.slice(0,5).forEach((i,o)=>{s(`  ${o+1}. ${i.selector} (${i.interaction}) - "${i.text.substring(0,50)}"`)}),r.length>5&&s(`  ... and ${r.length-5} more`)):(s("\u26A0\uFE0F No elements with elementId found. Sample elements:"),e.slice(0,3).forEach((i,o)=>{s(`  ${o+1}. text: "${i.text?.substring(0,50)||"N/A"}", elementId: "${i.elementId||"NONE"}", interaction: "${i.interaction||"N/A"}"`)})),r}catch(e){return s(`\u26A0\uFE0F Error extracting QA elements from DOM: ${e}`),[]}}d(yt,"extractQAElementsFromDOM");async function vt(n,e){let t=Date.now();s(`\u{1F50D} Starting QA hover analysis for ${e.length} elements`);try{let r=e.map(a=>({selector:a.selector,tagName:"unknown",text:a.text,attributes:{"data-qa-id":a.elementId,interaction:a.interaction},boundingBox:a.bounds,hoverIndicators:a.hasHover?["css-hover"]:["interactive"]}));r.length>0&&await ss(n,r);let i=Date.now()-t,o=r.filter(a=>a.hoverAnalysis?.changeIntensity&&a.hoverAnalysis.changeIntensity>0).map(a=>({elementId:a.attributes["data-qa-id"],changeIntensity:a.hoverAnalysis.changeIntensity}));return s(`\u2705 QA hover analysis complete! Found ${o.length} elements with hover changes (analyzed ${r.length} total) in ${i}ms`),{totalElements:o.length,hoverableElements:o,analysisTime:i}}catch(r){throw s(`\u274C QA hover analysis failed: ${r}`),r}}d(vt,"runHoverAnalysisOnQAElements");var Te=class n{static{d(this,"EvaluatorOptimizer")}static evalCalls=0;tool=new ge;args;constructor(e){this.args=e}async evaluate(e){let t=`evaluate-${++n.evalCalls}-${Date.now()}`;c.start("evaluate",{uid:t});try{s("=== [EvaluatorOptimizer] evaluate called: ===");let r=JSON.stringify(e,null,2);s(r),c.start("evaluate-request-validation",{uid:t});let i=await ot(e);if(c.end("evaluate-request-validation",{uid:t,hasError:!!i}),i)throw c.end("evaluate",{uid:t,result:"assertion-error"}),s("=== [EvaluatorOptimizer] assertion error: ==="),s(JSON.stringify(i,null,2)),i;s("=== [EvaluatorOptimizer] Starting parallel QA automation workflow ==="),A.evaluateStarted();let o=await this.executeQAWorkflow(e),a=o.decision==="PASS";return c.end("evaluate",{uid:t,result:o.decision}),{...o,systemNotifications:o.systemNotifications||[{type:a?"success":"warning",message:a?`${ce} has completed the evaluation. All passed!`:`${ce} has found ${o.feedbacks.length} ${pe(o.feedbacks.length,"issue")}. I'm on it!`,priority:"high",actionRequired:!a}]}}catch(r){throw c.end("evaluate",{uid:t,result:"error"}),s("=== [EvaluatorOptimizer] Error during evaluation: ==="),s(E(r)),se(r,new v({confidence:.1,feedbacks:[{text:"SYSTEM ERROR: Evaluator offline. FORBIDDEN to proceed without validation.",structured:{violation:`EVALUATOR_FAILURE: ${r.message}`,testId:"N/A",penalty:"$500"}}],metadata:{error:r.message},systemNotifications:[{type:"error",message:`${ce} is offline. Please contact support for assistance.`,priority:"high",actionRequired:!0}]})),r}}async executeQAWorkflow(e){let t=`workflow-${n.evalCalls}-${Date.now()}`;c.start("executeQAWorkflow",{uid:t});let{projectFolderPath:r,projectRunCommand:i,projectRunUrl:o,appDescription:a,targetTests:p,testIds:l,userPrompt:g,fps:u}=e,{start:m,only:h,onlyIndex:y,onlyTestId:w,ignoreIndices:b,ignoreStrings:_,"fail-fast":C,"manual-filter":L}=this.args,x,B;try{if(c.start("webapp-setup",{uid:t}),o)try{await he(o),x=o,s(`[EvaluatorOptimizer] Using provided webapp URL: ${o}`)}catch(f){c.end("webapp-setup",{uid:t,result:"url-validation-failed"}),c.end("executeQAWorkflow",{uid:t,result:"url-validation-failed"}),s("[EvaluatorOptimizer] Failed to validate provided webapp URL"),s(E(f));let P=o?.startsWith("file:///");throw new v({confidence:.1,feedbacks:[{text:P?`Cannot access the specified file at ${o}. Please ensure the file exists and is accessible.`:`Cannot connect to the specified running server at ${o}. Please ensure the server is running and accessible.`,structured:{violation:`${P?"FILE_NOT_FOUND":"RUNNING_SERVER_UNAVAILABLE"}: ${f?.message||"Unknown error"}`,testId:"N/A",severity:"BLOCKING"},suggestions:[{type:"action",content:P?`Verify that the file exists at the specified path: ${o}`:`Verify that the development server is running at ${o} and accessible.`,severity:"HIGH"}]}]})}else if(i)try{B=new re,x=(await B.startWebapp(r,i)).url,s(`[EvaluatorOptimizer] Started webapp at "${x}"`)}catch(f){throw c.end("webapp-setup",{uid:t,result:"webapp-start-failed"}),c.end("executeQAWorkflow",{uid:t,result:"webapp-start-failed"}),s("[EvaluatorOptimizer] Failed to start webapp"),s(E(f)),new v({confidence:.9,feedbacks:[{text:`Failed to start webapp: ${f.message}`,structured:{violation:`WEBAPP_START_FAILURE: ${f.message}`,testId:"N/A",severity:"BLOCKING"},suggestions:[{type:"action",content:"Check the project run command and ensure all dependencies are installed.",severity:"HIGH"}]}]})}if(!x)throw new Error("No webapp URL available - this should not happen");c.end("webapp-setup",{uid:t,webappUrl:x});let T=r.split("/").filter(Boolean).pop()||"unknown-app";s(`[EvaluatorOptimizer] Starting QA workflow for "${T}"`),c.start("sessions-preparation",{uid:t});let U=nt(r),$=we(r);if(y||w){s("[EvaluatorOptimizer] ========== --only parameter detected =========="),s(`[EvaluatorOptimizer] onlyIndex: ${y}`),s(`[EvaluatorOptimizer] onlyTestId: ${w}`),s(`[EvaluatorOptimizer] Original test plan length: ${$.length} characters`),s(`[EvaluatorOptimizer] Original test plan content (first 200 chars):
${$.substring(0,200)}...`);try{s("[EvaluatorOptimizer] Calling filterTestPlanCSV...");let f=await _e($,y,w);if(s("[EvaluatorOptimizer] filterTestPlanCSV returned successfully"),s(`[EvaluatorOptimizer] Filter result - found: ${f.found}, originalTestCount: ${f.originalTestCount}, filteredTestCount: ${f.filteredTestCount}`),!f.found){let P=w||`index ${y}`;throw new v({confidence:1,feedbacks:[{text:`Test not found: "${P}" does not exist in the test plan. Available tests: ${f.originalTestCount}`,structured:{violation:"INVALID_TEST_FILTER",testId:w||`index-${y}`,severity:"BLOCKING"},suggestions:[{type:"action",content:`Check your test plan and use a valid test ID or index (1-${f.originalTestCount})`,severity:"HIGH"}]}]})}s(`[EvaluatorOptimizer] Filtered test plan length: ${f.filteredCSV.length} characters`),s(`[EvaluatorOptimizer] Filtered test plan content:
${f.filteredCSV}`),$=f.filteredCSV,s("[EvaluatorOptimizer] Successfully applied filtered test plan")}catch(f){if(s(`[EvaluatorOptimizer] ERROR filtering test plan CSV: ${E(f)}`),s(`[EvaluatorOptimizer] Error stack: ${f instanceof Error?f.stack:"No stack trace"}`),f instanceof v)throw s("[EvaluatorOptimizer] Re-throwing CritiqueError for invalid test filter"),f;s("[EvaluatorOptimizer] Continuing with original test plan due to unexpected filtering error")}s("[EvaluatorOptimizer] ========== End --only parameter processing ==========")}else s(`[EvaluatorOptimizer] No --only parameter detected (onlyIndex: ${y}, onlyTestId: ${w})`);if(l&&Array.isArray(l)&&l.length>0){s("[EvaluatorOptimizer] ========== testIds parameter detected =========="),s(`[EvaluatorOptimizer] testIds: ${JSON.stringify(l)}`),s(`[EvaluatorOptimizer] Original test plan length: ${$.length} characters`);try{s("[EvaluatorOptimizer] Calling filterTestPlanByTestIds...");let f=await De($,l);if(s("[EvaluatorOptimizer] filterTestPlanByTestIds returned successfully"),s(`[EvaluatorOptimizer] Filter result - originalTestCount: ${f.originalTestCount}, filteredTestCount: ${f.filteredTestCount}`),s(`[EvaluatorOptimizer] Found testIds: ${JSON.stringify(f.foundTestIds)}`),s(`[EvaluatorOptimizer] Not found testIds: ${JSON.stringify(f.notFoundTestIds)}`),f.notFoundTestIds.length>0)throw new v({confidence:1,feedbacks:[{text:`Test IDs not found: ${f.notFoundTestIds.join(", ")} do not exist in the test plan. Found ${f.foundTestIds.length} of ${l.length} requested tests.`,structured:{violation:"INVALID_TEST_IDS",testId:"N/A",severity:"BLOCKING"},suggestions:[{type:"action",content:`Check your test plan. Valid testIds: ${f.foundTestIds.length>0?f.foundTestIds.join(", "):"(none found)"}`,severity:"HIGH"}]}]});if(f.filteredTestCount===0)throw new v({confidence:1,feedbacks:[{text:`No tests matched the provided testIds: ${l.join(", ")}`,structured:{violation:"NO_TESTS_MATCHED",testId:"N/A",severity:"BLOCKING"},suggestions:[{type:"action",content:`Verify testIds exist in the test plan (total tests: ${f.originalTestCount})`,severity:"HIGH"}]}]});s(`[EvaluatorOptimizer] Filtered test plan length: ${f.filteredCSV.length} characters`),s(`[EvaluatorOptimizer] Filtered test plan content:
${f.filteredCSV}`),$=f.filteredCSV,s("[EvaluatorOptimizer] Successfully applied filtered test plan")}catch(f){if(s(`[EvaluatorOptimizer] ERROR filtering test plan by testIds: ${E(f)}`),f instanceof v)throw s("[EvaluatorOptimizer] Re-throwing CritiqueError for invalid testIds"),f;s("[EvaluatorOptimizer] Continuing with original test plan due to unexpected filtering error")}s("[EvaluatorOptimizer] ========== End testIds parameter processing ==========")}else s("[EvaluatorOptimizer] No testIds parameter detected or empty array");let K=Oe(r),{sessions:I,runId:O}=await new z(this.args["api-url"]).asyncPrepWithStatePolling({app_uid:U,app_name:T,app_description:a,context:{timestamp:Date.now(),locale:Intl.DateTimeFormat().resolvedOptions().locale||"en_US"},initial_plan:$,user_flows:K,requirements:g,target_tests:JSON.stringify(p??[]),only:y||w?void 0:typeof h=="number"?h:void 0,start:m,ignore_indices:b,ignore_test_ids:_,thinking_budget:this.args["thinking-budget"],no_replay:this.args["no-replay"]||void 0});if(ct(I),s(`[EvaluatorOptimizer] Received ${I.length} QA sessions from /async_prep endpoint (after server-side filtering) for runId: ${O}`),I.length===0)throw c.end("sessions-preparation",{uid:t,result:"no-sessions-available"}),c.end("executeQAWorkflow",{uid:t,result:"no-sessions-available"}),new v({confidence:1,feedbacks:[{text:"No sessions available to run. This may be due to filtering parameters or no test plan available.",structured:{violation:"NO_SESSIONS_AVAILABLE",testId:"N/A",severity:"BLOCKING"},suggestions:[{type:"action",content:"Review your filtering parameters and ensure test plan is available.",severity:"HIGH"}]}],metadata:{filteredSessionCount:I.length,hasOnlyFilter:h!==void 0,hasStartFilter:m!==void 0,hasIgnoreFilters:(b?.length||0)+(_?.length||0)>0}});if(c.end("sessions-preparation",{uid:t,runId:O,sessionCount:I.length}),s(`[EvaluatorOptimizer] Prepared ${I.length} QA sessions:
${I.map(f=>f.session_uid).join(`
`)}`),qe)s("[EvaluatorOptimizer] Skipping dashboard opening in test environment");else{c.start("launching-dashboard",{uid:t,runId:O,sessionCount:I.length});try{let f=await ft(I,L,U,this.args["api-url"]);if(f?.length){let P=I.filter(D=>f.includes(D.test_id));s(`[EvaluatorOptimizer] Manual filter applied: ${P.length}/${I.length} sessions selected`),I.splice(0,I.length,...P)}c.end("launching-dashboard",{uid:t,runId:O,sessionCount:I.length})}catch(f){c.end("launching-dashboard",{uid:t,runId:O,sessionCount:I.length,error:f.message}),s("[EvaluatorOptimizer] Failed to open realtime browser"),s(E(f))}}let Fe=this.args.parallel??lt();s(`[EvaluatorOptimizer] Executing ${Fe} parallel instances ${this.args.parallel?"(user-specified)":"(auto-calculated)"}`);let Ue=os(Fe),Y=I.map((f,P)=>{let D=new AbortController,X=new z(this.args["api-url"],D.signal);s(`[EvaluatorOptimizer] Created executor for session ${f.session_uid} (testId: ${f.test_id})`);let R={},He=d(()=>{R.executorStartTime=Date.now(),R.testTimeoutMs=this.args["test-timeout"]*1e3,R.timeoutId=setTimeout(()=>{let ee=Date.now()-R.executorStartTime;s(`[EvaluatorOptimizer ${f.session_uid}] Test timeout after ${ee}ms (limit: ${R.testTimeoutMs}ms)`),Qe.abort()},R.testTimeoutMs)},"setExecutorTimeout"),Z=d(()=>{typeof R.timeoutId<"u"&&(clearTimeout(R.timeoutId),delete R.timeoutId)},"clearExecutorTimeout"),Tt=d(()=>{s(`[EvaluatorOptimizer ${f.session_uid}] Resetting test timeout`),Z(),He()},"resetExecutorTimeout"),Qe={session:f,execute:d(ee=>Ue(async()=>{s(`[EvaluatorOptimizer] Starting task ${P+1}/${I.length}: ${f.session_uid} (testId: ${f.test_id})`),He(),gt(f.session_uid);try{let Q=await this.#e(f,x,X,D,Tt,r,O,u,ee);return Z(),Q}catch(Q){if(Z(),await Le(f.session_uid,{decision:"CRITIQUE",feedbacks:[{structured:{error:Q.message}}]}),Q instanceof v)return{result:Q.toEvaluationResult()};let je=Date.now()-R.executorStartTime;if(D.signal.aborted&&je>=R.testTimeoutMs)return{result:new v({confidence:1,feedbacks:[{text:`Test execution timed out after ${this.args["test-timeout"]} seconds. This is considered a stale test.`,structured:{violation:"STALE_TEST",severity:"HIGH",testId:f.test_id},suggestions:[{type:"action",content:"Review test complexity or increase timeout limit with --test-timeout parameter",severity:"HIGH"}]}],metadata:{staleTest:!0,executionTimeMs:je,timeoutLimitMs:R.testTimeoutMs}}).toEvaluationResult()};throw Q}finally{Z(),A.incrementCompletedTests()}}),"execute"),abort:d(()=>{Z(),s(`[EvaluatorOptimizer ${f.session_uid}] Aborting session`),X.abort(f.session_uid).catch(ee=>{s(`[EvaluatorOptimizer ${f.session_uid}] Failed to call abort API: ${ee.message}`)}).finally(()=>{D.abort(),Be(f.session_uid)})},"abort")};return Qe});A.setTotalTests(Y.length),A.testsExecutionStarted(),c.start("tests-execution",{uid:t,runId:O,sessionCount:I.length});let le,Me=d((f,P=void 0)=>{let D=f.session.session_uid,X=f.session.test_id;return f.execute(P).then(R=>(s(`[EvaluatorOptimizer ${D}] Test ${X} completed with decision: ${R.result.decision}, error: ${R.error??"None"}`),R)).catch(R=>{throw s(`[EvaluatorOptimizer ${D}] Test ${X} failed with error: ${E(R)}`),R})},"getExecutorPromise"),Ve;await new Promise(f=>{let P=setTimeout(()=>{f(!0)},1e4);Ve=Me(Y[0],()=>{clearTimeout(P),f(!0)})});let ze=[Ve??Promise.resolve(!0),...Y.slice(1).map(f=>Me(f))];C?le=await We(ze,async(f,{result:P,error:D})=>!D&&P.decision==="PASS",async f=>{Ue.clearQueue(),f.forEach(P=>{Y[P].abort()})}):le=(await Promise.allSettled(ze)).map((f,P)=>{switch(f.status){case"fulfilled":return f.value;case"rejected":{let D=v.fromError(f.reason,Y[P].session.test_id);return{result:D.toEvaluationResult(),error:D}}}}),c.end("tests-execution",{uid:t,runId:O,resultCount:le.length}),c.start("result-aggregation",{uid:t,runId:O});let Se=at(le);return c.end("result-aggregation",{uid:t,runId:O,decision:Se.decision}),c.end("executeQAWorkflow",{uid:t,result:Se.decision}),Se}catch(T){c.end("executeQAWorkflow",{uid:t,error:T.message}),s("[EvaluatorOptimizer] Error in QA workflow execution:"),s(E(T));let U=T?.message||"Unknown error";throw se(T,new v({confidence:.1,feedbacks:[{text:`QA automation failed: ${U}`,structured:{violation:`QA_WORKFLOW_FAILURE: ${U}`,testId:"N/A",severity:"BLOCKING"},suggestions:[{type:"action",content:"Check the project setup and ensure all dependencies are available.",severity:"HIGH"}]}]})),T}finally{await B?.stopWebapp()}}async#e(e,t,r,i,o,a,p,l,g){let u=e.session_uid,m=e.test_id;c.start("qa-session",{uid:u,testId:m});let h=new fe(e,t,!this.args["no-headless"],this.args.viewport);try{await h.launchBrowser(),await new Promise(_=>setTimeout(_,2e3));let y=await h.getViewportBounds(),w=await h.takeScreenshot(y);await ke(Ne(e,0,w));let b=await this.#t(e,h,r,i,o,a,p,l,g);return c.end("qa-session",{uid:u,testId:m,decision:b.decision}),{result:b}}catch(y){if(i.signal.aborted)return c.end("qa-session",{uid:u,testId:m,result:"aborted"}),s(`[EvaluatorOptimizer ${u}] execution aborted`),await Be(u),{result:new v({confidence:0,feedbacks:[{text:"QA session aborted",structured:{violation:"QA_AUTOMATION_ABORTED",testId:m}}],metadata:{aborted:!0}}).toEvaluationResult()};c.end("qa-session",{uid:u,testId:m,result:"error"}),s(`[EvaluatorOptimizer ${u}] execution error (testId: ${m})`),s(E(y));let w=y?.message||"Unknown error";throw se(y,new v({confidence:.1,feedbacks:[{text:`QA automation failed: ${w}`,structured:{violation:`QA_SESSION_FAILURE: ${w}`,testId:m,severity:"BLOCKING"},suggestions:[{type:"action",content:"Check the project setup and ensure all dependencies are available.",severity:"HIGH"}]}]})),y}finally{await h.cleanup()}}async#t(e,t,r,i,o,a,p,l,g){let u=e.session_uid,m=e.test_id;c.start("qa-loop",{uid:u,testId:m});let h=!0,y,w,b,_;for(;h;){if(i.signal.aborted)throw s(`[executeQALoop ${u}] Loop aborted by abort controller`),new Error("QA loop aborted");let C=y?.curr_step??0;try{c.start("qa-step",{uid:u,testId:m,step:`${C}`});let L=await t.extractDOM(),x=await t.getViewportBounds(),B=L.viewport?.devicePixelRatio||await t.getDevicePixelRatio();await t.freezePage();let T,U;try{let $=await t.takeScreenshot();if(this.args["save-debug-screenshots"])try{Je(a,p,u,C,$)}catch{}U=await t.takeScreenshot(x);let K={x0:x.x0*B,y0:x.y0*B,x1:x.x1*B,y1:x.y1*B},I={dom:L,screenshot:$,viewportBounds:K,...w&&{error:w},...b&&{last_action_uid:b},..._&&{deep_explore_results:_}};T=await r.step(e.session_uid,I),C===0&&g?.()}finally{await t.unfreezePage()}if(b?s(`[executeQALoop ${u}] Sending last_action_uid: ${b}`):s(`[executeQALoop ${u}] No last_action_uid to send (first request or no previous action_uid)`),w=void 0,_=void 0,b=T.action_uid,T.deep_explore_page){s("\u{1F50D} Server requested deep page exploration - running hover analysis");try{let $=yt(L);if($.length>0){s(`\u{1F3AF} Running hover analysis on ${$.length} QA elements for deep exploration`);let K=await t.getPage();_={hover_analysis:await vt(K,$),triggeredByStep:C,explorationTimestamp:new Date().toISOString()},s("\u2705 Deep exploration complete - results will be sent in next step"),s(`\u{1F50D} STORED deep_explore_results: ${JSON.stringify(_,null,2)}`)}else s("\u26A0\uFE0F No QA elements found for deep exploration")}catch($){s(`\u274C Deep exploration failed: ${$}`)}}if(s(`[executeQALoop ${u}] Received step response  ${JSON.stringify({action:T.action,currStep:C,action_uid:T.action_uid})}`),T.action==="FINISH"&&s(`[executeQALoop ${u}] FINISH response - action: ${T.action}, action_uid: ${T.action_uid}`),T.session_status&&T.action!=="FINISH"&&(y=T.session_status,await ke(Ne(e,C,U))),h=await this.#r(T,t,o,l),c.end("qa-step",{uid:u,testId:m,step:`${C}`,action:T.action,shouldContinue:h}),!h){let $=JSON.parse(T.result);return c.end("qa-loop",{uid:u,testId:m,step:`${C}`,decision:$.decision}),s(`[executeQALoop ${u}] FINISH action - Parsed result: ${JSON.stringify($,null,2)}`),await Le(u,{decision:$.decision,confidence:$.confidence,feedbacks:$.feedbacks,metadata:$.metadata}),$}}catch(L){let x=L.message;if(this.#s(x)){w=x,s(`[executeQALoop ${u}] Selector error at step ${C}, will propagate to next step: ${x}`),c.end("qa-step",{uid:u,testId:m,step:`${C}`,result:"selector-error-propagated"});continue}else c.end("qa-step",{uid:u,testId:m,step:`${C}`,result:"error"}),c.end("qa-loop",{uid:u,testId:m,step:`${C}`,result:"error"}),s(`[EvaluatorOptimizer ${u}] Error in QA loop, Task ${m}, Step ${C}`),s(E(L)),se(L,new v({confidence:.1,feedbacks:[{text:`QA automation failed at task ${m}, step ${C}:
${x}`,structured:{violation:`QA_STEP_FAILURE: ${x}`,testId:`${m}`,step:`${C}`}}],metadata:{failedStep:C}}))}}throw new Error("QA automation loop ended without FINISH action")}#s(e){return e.includes("Failed to focus on element with selector")||e.includes("Failed to click on element with selector")||e.includes("Cannot find element with selector")||e.includes("data-qa-id")}async#r(e,t,r,i){switch(e.action){case"RESET":return e.is_replay&&(s("[processQAAction] RESET with is_replay=true: Resetting test timeout"),r()),await t.resetPageState(),e.focus&&await t.focusElement(e.focus),e.native_click&&await t.clickElement(e.native_click),e.keystroke!==void 0&&await t.pressKey(e.keystroke),e.script&&await t.executeScript(e.script),!0;case"INJECT":return e.focus&&await t.focusElement(e.focus),e.native_click&&await t.clickElement(e.native_click),e.keystroke!==void 0&&await t.pressKey(e.keystroke),e.script&&await t.executeScript(e.script),await new Promise(o=>setTimeout(o,i?1e3/i+50:500)),!0;case"FINISH":return s("[processQAAction] FINISH: QA automation completed"),!1;default:throw new Error(`Unknown QA action: ${e.action}`)}}async initMcpConfig(){return this.tool.init(this.args["api-url"])}async getTools(){return this.tool.getAll(this.args["api-url"])}async getTool(e){return this.tool.get(this.args["api-url"],e)}async validateTestPlan(e){if(s("=== [validateTestPlan] Tool called ==="),s(JSON.stringify(e,null,2)),!e.projectFolderPath)return s("[validateTestPlan] ERROR: projectFolderPath parameter is required"),{status:"ERROR",message:"projectFolderPath parameter is required"};s(`[validateTestPlan] Reading test plan from ${e.projectFolderPath}`);let t;try{t=we(e.projectFolderPath),s(`[validateTestPlan] Read ${t.length} characters from file`)}catch(i){return s(`[validateTestPlan] Failed to read test plan file: ${E(i)}`),{status:"ERROR",message:`Failed to read test plan file: ${i.message}`}}if(!t||t.trim().length===0)return s("[validateTestPlan] Test plan file is empty"),{status:"ERROR",message:"Test plan file is empty. Please provide a valid CSV test plan."};let r=await G(t);return r.isValid?(s("[validateTestPlan] Validation passed successfully"),{status:"OK",message:"Test plan validation passed successfully"}):(s(`[validateTestPlan] Validation failed: ${r.error}`),{status:"ERROR",message:`Test plan validation failed: ${r.error||"Invalid CSV format"}`})}};var ms=0,q,ae=[],J=new as({name:"evaluator-optimizer-mcp",version:j},{capabilities:{tools:{},prompts:{}}});J.setRequestHandler(cs,async()=>{try{return{tools:await q.getTools()}}catch(n){return s("FATAL ERROR!!! Failed to get tool definitions:",n),{tools:[]}}});J.setRequestHandler(ls,async n=>{let{name:e,arguments:t,_meta:r}=n.params,i=`req-${++ms}-${Date.now()}`;A.initialize({progressToken:r?.progressToken,server:J}),A.toolCalled(),c.start("tool-call-handler",{uid:i,toolName:e});try{let o=await q.getTool(e);if(!o)throw c.end("tool-call-handler",{uid:i,result:"tool-not-found"}),A.fail(`Tool not found: ${e}`),A.completeAfterFailure(),new Error(`Tool not found: ${e}`);s(`=== Tool called: ${e} ===`);try{c.start("input-validation",{uid:i}),s("=== Validating tool-called input ===");let a=new ps,p=a.compile(o.inputSchema),l=p(t);if(c.end("input-validation",{uid:i,valid:l}),!l)throw c.end("tool-call-handler",{uid:i,result:"validation-failed"}),new v({confidence:1,feedbacks:[{text:"SYSTEM ERROR: Validation failed. FORBIDDEN to proceed.",structured:{violation:`VALIDATION_FAILURE: ${a.errorsText(p.errors)}`,testId:"N/A",penalty:"$1000"},suggestions:[{type:"action",content:"Fix validation errors and retry. NO EXCEPTIONS.",severity:"HIGH"}]}]});s("=== Tool-called input validated successfully: ==="),s(JSON.stringify(t,null,2)),A.toolValidated(),c.start("tool-execution",{uid:i,toolName:e});let g;switch(e){case"validate_updated_test_plan":g=await q.validateTestPlan(t);break;default:g=await q.evaluate(t);break}return c.end("tool-execution",{uid:i,toolName:e}),A.complete(),s(`=== Tool execution completed: ${e} ===`),s(JSON.stringify(g,null,2)),c.end("tool-call-handler",{uid:i,result:"success"}),{content:[{type:"text",text:JSON.stringify(g,null,2)}]}}catch(a){c.end("evaluation",{uid:i,error:a.message}),c.end("tool-call-handler",{uid:i,error:a.message}),A.fail(a.message),s("=== ERROR in tool handler ==="),s(E(a));let p;return a instanceof v?p=a.toEvaluationResult():p={decision:"CRITIQUE",confidence:.1,feedbacks:[{text:"SYSTEM ERROR: Validation failed. FORBIDDEN to proceed.",structured:{violation:`VALIDATION_FAILURE: ${a.message||"Unknown error"}`,testId:"N/A",penalty:"$1000"},suggestions:[{type:"action",content:"Fix validation errors and retry. NO EXCEPTIONS.",severity:"HIGH"}]}],metadata:{evaluationTime:Date.now(),evaluatorVersion:j}},A.completeAfterFailure(),{content:[{type:"text",text:JSON.stringify(p,null,2)}]}}}catch(o){throw c.end("tool-call-handler",{uid:i,error:o.message}),A.fail(o.message),A.completeAfterFailure(),s("FATAL ERROR!!! Failed to get tool:"),s(E(o)),o}});J.setRequestHandler(ds,async()=>{try{return s(`[ListPromptsRequestSchema] Returning ${ae.length} prompts`),{prompts:ae.map(n=>({name:n.name,description:n.description}))}}catch(n){return s("ERROR!!! Failed to list prompts:",n),{prompts:[]}}});J.setRequestHandler(us,async n=>{try{let{name:e}=n.params;s(`[GetPromptRequestSchema] Requested prompt: ${e}`);let t=ae.find(r=>r.name===e);if(!t)throw new Error(`Prompt not found: ${e}`);return{description:t.description,messages:[{role:"user",content:{type:"text",text:t.description}}]}}catch(e){throw s("ERROR!!! Failed to get prompt:",e),e}});var bt=d(async(n,e)=>{q=new Te(e),await J.connect(n),s("[MCP Server Init] Initializing MCP configuration");try{ae=(await q.initMcpConfig()).commands,s(`[MCP Server Init] Loaded ${ae.length} command(s) as MCP prompts`)}catch(t){s("[MCP Server Init] Failed to initialize MCP configuration:"),s(E(t))}s(`Evaluator-Optimizer MCP Server v${j} running on stdio`)},"start");import fs from"arg";var Et=d(n=>{let e={"--start":{description:"Start with test number n (skip tests 1 to n-1). Must be \u2265 1.",context:["cli"],argDisplay:"--start n"},"--only":{description:"Run only test number n (if integer) or testId (if string). Cannot be used with --start or --ignore.",context:["cli"],argDisplay:"--only n|testId"},"--ignore":{description:"Ignore test with index n (if number) or testId (if string). Can be used multiple times.",context:["cli"],continuation:"Cannot be used with --only.",argDisplay:"--ignore n|id"},"--parallel":{description:"Set maximum parallel instances (default: auto-calculated). Must be \u2265 1.",context:["cli","server"],argDisplay:"--parallel n"},"--keep-alive":{description:"Keep process alive after evaluation (don't exit). Default: false.",context:["cli"],argDisplay:"--keep-alive"},"--fail-fast":{description:"Enable/disable fail-fast mode. Accepts: 'true', 'false', '1', '0'. Default: true.",context:["cli","server"],continuation:"When false, continues all tasks even if one fails.",argDisplay:"--fail-fast arg"},"--manual-filter":{description:"Show test selection UI in dashboard before running tests. Default: false.",context:["cli","server"],argDisplay:"--manual-filter"},"--test-timeout":{description:"Set test execution timeout in seconds. Default: 300 seconds (5 minutes).",context:["cli","server"],argDisplay:"--test-timeout n"},"--api-url":{description:'Override the API base URL. Default: "https://api.qaijit.com"',context:["cli","server"],argDisplay:"--api-url url"},"--output":{description:"Save evaluation results to JSON file instead of console output",context:["cli"],argDisplay:"--output filename.json"},"--help":{description:"Show this help message",context:["cli","server"],argDisplay:"--help"},"--no-headless":{description:"Show browser windows during QA automation (for debugging). Default: false.",context:["cli"],argDisplay:"--no-headless"},"--thinking-budget":{description:"Set thinking budget for evaluation processing. Accepts any integer (including 0 and -1).",context:["cli","server"],argDisplay:"--thinking-budget n"},"--viewport":{description:"Set browser viewport size in WIDTHxHEIGHT format (e.g., 1920x1080). Default: system natural viewport.",context:["cli"],argDisplay:"--viewport WIDTHxHEIGHT"},"--analyze-hover-impact":{description:"Perform visual analysis of hover effects (takes screenshots, slower but more detailed).",context:["cli"],argDisplay:"--analyze-hover-impact"},"--save-debug-screenshots":{description:"Save debug screenshots to disk during evaluation and hover analysis. Default: false.",context:["cli"],argDisplay:"--save-debug-screenshots"},"--no-replay":{description:"Disable replay mode for test execution. Default: false.",context:["cli","server"],argDisplay:"--no-replay"}},t=["\u2022 --start and --only cannot be used together","\u2022 --ignore cannot be used with --only","\u2022 All numeric parameters must be positive integers (\u2265 1)"];return{arguments:Object.entries(e).filter(([i,o])=>o.context.includes(n)).map(([i,o])=>({arg:i,argDisplay:o.argDisplay,description:o.description,continuation:o.continuation})),parameterRestrictions:n==="cli"?t:[]}},"getArgumentDescriptions"),$t=d(n=>{let e=fs({"--start":Number,"--only":String,"--parallel":Number,"--test-timeout":Number,"--thinking-budget":Number,"--api-url":String,"--output":String,"--fail-fast":String,"--viewport":String,"--keep-alive":Boolean,"--help":Boolean,"--manual-filter":Boolean,"--no-headless":Boolean,"--analyze-hover-impact":Boolean,"--save-debug-screenshots":Boolean,"--no-replay":Boolean,"--ignore":[String]},{argv:n,permissive:!1}),t={_:e._,"api-url":"https://api.qaijit.com","fail-fast":!0,"keep-alive":!1,"manual-filter":!1,"no-headless":!1,"analyze-hover-impact":!1,"save-debug-screenshots":!1,"no-replay":!1,"test-timeout":300};if(typeof e["--start"]<"u"){let r=e["--start"];if(isNaN(r)||r<1)throw new Error("--start parameter must be a positive number (1 or greater)");t.start=r,s(`Will start with test ${t.start} (skip tests 1-${t.start-1}) `)}if(typeof e["--only"]<"u"){let r=e["--only"];s("[parseCommandLineArgs] ========== Parsing --only parameter =========="),s(`[parseCommandLineArgs] Raw --only value: "${r}"`),s(`[parseCommandLineArgs] Type of --only value: ${typeof r}`);let i=parseInt(r,10);if(s(`[parseCommandLineArgs] Parsed numeric value: ${i}`),s(`[parseCommandLineArgs] Is numeric: ${!isNaN(i)}`),s(`[parseCommandLineArgs] Is positive: ${i>0}`),s(`[parseCommandLineArgs] String representation matches: ${i.toString()===r}`),!isNaN(i)&&i>0&&i.toString()===r)t.only=i,t.onlyIndex=i,s(`[parseCommandLineArgs] \u2705 Parsed --only as numeric index: ${t.only}`),s(`[parseCommandLineArgs] result.onlyIndex = ${t.onlyIndex}`);else if(r.trim().length>0)t.only=r,t.onlyTestId=r,s(`[parseCommandLineArgs] \u2705 Parsed --only as string testId: "${t.only}"`),s(`[parseCommandLineArgs] result.onlyTestId = "${t.onlyTestId}"`);else throw new Error("--only parameter must be a positive number (1 or greater) or a non-empty testId string");s("[parseCommandLineArgs] ========== End --only parameter parsing ==========")}else s("[parseCommandLineArgs] No --only parameter provided");if(typeof e["--parallel"]<"u"){let r=e["--parallel"];if(isNaN(r)||r<1)throw new Error("--parallel parameter must be a positive number (1 or greater)");t.parallel=r,s(`--parallel: Will run up to ${t.parallel} instances`)}if(typeof e["--test-timeout"]<"u"){let r=e["--test-timeout"];if(isNaN(r)||r<1)throw new Error("--test-timeout parameter must be a positive number (1 or greater)");t["test-timeout"]=r}if(s(`--test-timeout: Will use timeout of ${t["test-timeout"]} seconds`),e["--api-url"]&&(t["api-url"]=e["--api-url"]),s(`--api-url: Will use API base URL "${t["api-url"]}"`),e["--output"]&&(t.output=e["--output"],s(`--output: Will save results to JSON file "${t.output}"`)),typeof e["--keep-alive"]<"u"&&(t["keep-alive"]=e["--keep-alive"]),s(`--keep-alive: Will set keep alive to ${t["keep-alive"]}`),typeof e["--help"]<"u"&&(t.help=e["--help"]),typeof e["--manual-filter"]<"u"&&(t["manual-filter"]=e["--manual-filter"]),s(`--manual-filter: Manual filter mode: ${t["manual-filter"]?"enabled":"disabled"}`),typeof e["--no-headless"]<"u"&&(t["no-headless"]=e["--no-headless"]),s(`--no-headless: Browser visibility mode: ${t["no-headless"]?"enabled (browsers visible)":"disabled (headless)"}`),typeof e["--analyze-hover-impact"]<"u"&&(t["analyze-hover-impact"]=e["--analyze-hover-impact"]),s(`--analyze-hover-impact: Visual hover analysis: ${t["analyze-hover-impact"]?"enabled":"disabled"}`),typeof e["--save-debug-screenshots"]<"u"&&(t["save-debug-screenshots"]=e["--save-debug-screenshots"]),s(`--save-debug-screenshots: Debug screenshot saving: ${t["save-debug-screenshots"]?"enabled":"disabled"}`),typeof e["--no-replay"]<"u"&&(t["no-replay"]=e["--no-replay"]),s(`--no-replay: Replay mode: ${t["no-replay"]?"disabled":"enabled"}`),typeof e["--thinking-budget"]<"u"){let r=e["--thinking-budget"];if(isNaN(r))throw new Error("--thinking-budget parameter must be a valid number");t["thinking-budget"]=r,s(`--thinking-budget: Will use thinking budget of ${t["thinking-budget"]}`)}if(typeof e["--viewport"]<"u"){let r=e["--viewport"];s("[parseCommandLineArgs] ========== Parsing --viewport parameter =========="),s(`[parseCommandLineArgs] Raw --viewport value: "${r}"`);let i=r.match(/^(\d+)x(\d+)$/);if(!i)throw new Error("--viewport parameter must be in format WIDTHxHEIGHT (e.g., 1920x1080)");let o=parseInt(i[1],10),a=parseInt(i[2],10);if(o<100||o>4e3)throw new Error("--viewport width must be between 100 and 4000 pixels");if(a<100||a>4e3)throw new Error("--viewport height must be between 100 and 4000 pixels");t.viewport={width:o,height:a},s(`Will use viewport size: ${o}x${a}`)}if(e["--ignore"]){let r=e["--ignore"],i=[],o=[];for(let a of r){let p=parseInt(a,10);!isNaN(p)&&p>0?i.push(p):o.push(a)}t.ignoreIndices=i,s(`Will ignore test indices: ${t.ignoreIndices.join(", ")}`),t.ignoreStrings=o,s(`Will ignore test IDs: ${t.ignoreStrings.join(", ")}`)}if(typeof e["--fail-fast"]<"u"){let r=e["--fail-fast"];if(r==="false"||r==="0")t["fail-fast"]=!1;else if(r==="true"||r==="1")t["fail-fast"]=!0;else throw new Error("Invalid value for --fail-fast: must be 'true', 'false', '1', or '0'")}if(s(`Fail-fast mode: ${t["fail-fast"]?"enabled":"disabled"}`),t.start!==void 0&&t.only!==void 0)throw new Error("--start and --only parameters cannot be used together");if(t.only!==void 0&&(t.ignoreIndices?.length||t.ignoreStrings?.length))throw new Error("--ignore parameters cannot be used with --only");return t},"parseCommandLineArgs");function hs(){console.log(`
Usage: mcp-evaluator-optimizer [options]

MCP Server for evaluating and optimizing MCP server implementations.

Server Options:`),Et("server").arguments.forEach(({argDisplay:n,description:e,continuation:t})=>{console.log(`  ${n.padEnd(18)} ${e}`),t&&console.log(`                     ${t}`)}),console.log(`

Note: This is the MCP server. For CLI evaluation tool, use:
  node dist/cli --help
`)}d(hs,"showServerHelp");var ws=d(async()=>{let n=$t(process.argv.slice(2));n.help&&(hs(),process.exit(0));let e=new gs;await bt(e,n)},"start");ws().catch(async n=>{s("Server error:",n),await V.cleanup(),process.exit(1)});export{E as stringifyError};
